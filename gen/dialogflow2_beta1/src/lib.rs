// DO NOT EDIT !
// This file was generated automatically from 'src/mako/api/lib.rs.mako'
// DO NOT EDIT !

//! This documentation was generated from *Dialogflow* crate version *1.0.8+20181009*, where *20181009* is the exact revision of the *dialogflow:v2beta1* schema built by the [mako](http://www.makotemplates.org/) code generator *v1.0.8*.
//! 
//! Everything else about the *Dialogflow* *v2_beta1* API can be found at the
//! [official documentation site](https://cloud.google.com/dialogflow-enterprise/).
//! The original source code is [on github](https://github.com/Byron/google-apis-rs/tree/master/gen/dialogflow2_beta1).
//! # Features
//! 
//! Handle the following *Resources* with ease from the central [hub](struct.Dialogflow.html) ... 
//! 
//! * projects
//!  * [*agent entity types batch delete*](struct.ProjectAgentEntityTypeBatchDeleteCall.html), [*agent entity types batch update*](struct.ProjectAgentEntityTypeBatchUpdateCall.html), [*agent entity types create*](struct.ProjectAgentEntityTypeCreateCall.html), [*agent entity types delete*](struct.ProjectAgentEntityTypeDeleteCall.html), [*agent entity types entities batch create*](struct.ProjectAgentEntityTypeEntityBatchCreateCall.html), [*agent entity types entities batch delete*](struct.ProjectAgentEntityTypeEntityBatchDeleteCall.html), [*agent entity types entities batch update*](struct.ProjectAgentEntityTypeEntityBatchUpdateCall.html), [*agent entity types get*](struct.ProjectAgentEntityTypeGetCall.html), [*agent entity types list*](struct.ProjectAgentEntityTypeListCall.html), [*agent entity types patch*](struct.ProjectAgentEntityTypePatchCall.html), [*agent environments users sessions contexts create*](struct.ProjectAgentEnvironmentUserSessionContextCreateCall.html), [*agent environments users sessions contexts delete*](struct.ProjectAgentEnvironmentUserSessionContextDeleteCall.html), [*agent environments users sessions contexts get*](struct.ProjectAgentEnvironmentUserSessionContextGetCall.html), [*agent environments users sessions contexts list*](struct.ProjectAgentEnvironmentUserSessionContextListCall.html), [*agent environments users sessions contexts patch*](struct.ProjectAgentEnvironmentUserSessionContextPatchCall.html), [*agent environments users sessions delete contexts*](struct.ProjectAgentEnvironmentUserSessionDeleteContextCall.html), [*agent environments users sessions detect intent*](struct.ProjectAgentEnvironmentUserSessionDetectIntentCall.html), [*agent environments users sessions entity types create*](struct.ProjectAgentEnvironmentUserSessionEntityTypeCreateCall.html), [*agent environments users sessions entity types delete*](struct.ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall.html), [*agent environments users sessions entity types get*](struct.ProjectAgentEnvironmentUserSessionEntityTypeGetCall.html), [*agent environments users sessions entity types list*](struct.ProjectAgentEnvironmentUserSessionEntityTypeListCall.html), [*agent environments users sessions entity types patch*](struct.ProjectAgentEnvironmentUserSessionEntityTypePatchCall.html), [*agent export*](struct.ProjectAgentExportCall.html), [*agent import*](struct.ProjectAgentImportCall.html), [*agent intents batch delete*](struct.ProjectAgentIntentBatchDeleteCall.html), [*agent intents batch update*](struct.ProjectAgentIntentBatchUpdateCall.html), [*agent intents create*](struct.ProjectAgentIntentCreateCall.html), [*agent intents delete*](struct.ProjectAgentIntentDeleteCall.html), [*agent intents get*](struct.ProjectAgentIntentGetCall.html), [*agent intents list*](struct.ProjectAgentIntentListCall.html), [*agent intents patch*](struct.ProjectAgentIntentPatchCall.html), [*agent knowledge bases create*](struct.ProjectAgentKnowledgeBaseCreateCall.html), [*agent knowledge bases delete*](struct.ProjectAgentKnowledgeBaseDeleteCall.html), [*agent knowledge bases documents create*](struct.ProjectAgentKnowledgeBaseDocumentCreateCall.html), [*agent knowledge bases documents delete*](struct.ProjectAgentKnowledgeBaseDocumentDeleteCall.html), [*agent knowledge bases documents get*](struct.ProjectAgentKnowledgeBaseDocumentGetCall.html), [*agent knowledge bases documents list*](struct.ProjectAgentKnowledgeBaseDocumentListCall.html), [*agent knowledge bases get*](struct.ProjectAgentKnowledgeBaseGetCall.html), [*agent knowledge bases list*](struct.ProjectAgentKnowledgeBaseListCall.html), [*agent restore*](struct.ProjectAgentRestoreCall.html), [*agent search*](struct.ProjectAgentSearchCall.html), [*agent sessions contexts create*](struct.ProjectAgentSessionContextCreateCall.html), [*agent sessions contexts delete*](struct.ProjectAgentSessionContextDeleteCall.html), [*agent sessions contexts get*](struct.ProjectAgentSessionContextGetCall.html), [*agent sessions contexts list*](struct.ProjectAgentSessionContextListCall.html), [*agent sessions contexts patch*](struct.ProjectAgentSessionContextPatchCall.html), [*agent sessions delete contexts*](struct.ProjectAgentSessionDeleteContextCall.html), [*agent sessions detect intent*](struct.ProjectAgentSessionDetectIntentCall.html), [*agent sessions entity types create*](struct.ProjectAgentSessionEntityTypeCreateCall.html), [*agent sessions entity types delete*](struct.ProjectAgentSessionEntityTypeDeleteCall.html), [*agent sessions entity types get*](struct.ProjectAgentSessionEntityTypeGetCall.html), [*agent sessions entity types list*](struct.ProjectAgentSessionEntityTypeListCall.html), [*agent sessions entity types patch*](struct.ProjectAgentSessionEntityTypePatchCall.html), [*agent train*](struct.ProjectAgentTrainCall.html), [*conversation profiles create*](struct.ProjectConversationProfileCreateCall.html), [*conversation profiles delete*](struct.ProjectConversationProfileDeleteCall.html), [*conversation profiles get*](struct.ProjectConversationProfileGetCall.html), [*conversation profiles list*](struct.ProjectConversationProfileListCall.html), [*conversation profiles patch*](struct.ProjectConversationProfilePatchCall.html), [*conversations add conversation phone number*](struct.ProjectConversationAddConversationPhoneNumberCall.html), [*conversations complete*](struct.ProjectConversationCompleteCall.html), [*conversations create*](struct.ProjectConversationCreateCall.html), [*conversations get*](struct.ProjectConversationGetCall.html), [*conversations list*](struct.ProjectConversationListCall.html), [*conversations messages list*](struct.ProjectConversationMessageListCall.html), [*conversations participants analyze content*](struct.ProjectConversationParticipantAnalyzeContentCall.html), [*conversations participants create*](struct.ProjectConversationParticipantCreateCall.html), [*conversations participants get*](struct.ProjectConversationParticipantGetCall.html), [*conversations participants list*](struct.ProjectConversationParticipantListCall.html), [*conversations participants streaming analyze content*](struct.ProjectConversationParticipantStreamingAnalyzeContentCall.html), [*conversations participants suggestions list*](struct.ProjectConversationParticipantSuggestionListCall.html), [*environments users conversations contexts create*](struct.ProjectEnvironmentUserConversationContextCreateCall.html), [*environments users conversations contexts delete*](struct.ProjectEnvironmentUserConversationContextDeleteCall.html), [*environments users conversations contexts get*](struct.ProjectEnvironmentUserConversationContextGetCall.html), [*environments users conversations contexts list*](struct.ProjectEnvironmentUserConversationContextListCall.html), [*environments users conversations contexts patch*](struct.ProjectEnvironmentUserConversationContextPatchCall.html), [*environments users conversations delete contexts*](struct.ProjectEnvironmentUserConversationDeleteContextCall.html), [*get agent*](struct.ProjectGetAgentCall.html), [*human agent assistants compile suggestions*](struct.ProjectHumanAgentAssistantCompileSuggestionCall.html), [*human agent assistants create*](struct.ProjectHumanAgentAssistantCreateCall.html), [*human agent assistants delete*](struct.ProjectHumanAgentAssistantDeleteCall.html), [*human agent assistants get*](struct.ProjectHumanAgentAssistantGetCall.html), [*human agent assistants list*](struct.ProjectHumanAgentAssistantListCall.html), [*human agent assistants patch*](struct.ProjectHumanAgentAssistantPatchCall.html), [*knowledge bases create*](struct.ProjectKnowledgeBaseCreateCall.html), [*knowledge bases delete*](struct.ProjectKnowledgeBaseDeleteCall.html), [*knowledge bases documents create*](struct.ProjectKnowledgeBaseDocumentCreateCall.html), [*knowledge bases documents delete*](struct.ProjectKnowledgeBaseDocumentDeleteCall.html), [*knowledge bases documents get*](struct.ProjectKnowledgeBaseDocumentGetCall.html), [*knowledge bases documents list*](struct.ProjectKnowledgeBaseDocumentListCall.html), [*knowledge bases get*](struct.ProjectKnowledgeBaseGetCall.html), [*knowledge bases list*](struct.ProjectKnowledgeBaseListCall.html), [*operations get*](struct.ProjectOperationGetCall.html), [*phone number orders cancel*](struct.ProjectPhoneNumberOrderCancelCall.html), [*phone number orders create*](struct.ProjectPhoneNumberOrderCreateCall.html), [*phone number orders get*](struct.ProjectPhoneNumberOrderGetCall.html), [*phone number orders list*](struct.ProjectPhoneNumberOrderListCall.html), [*phone number orders patch*](struct.ProjectPhoneNumberOrderPatchCall.html), [*phone numbers delete*](struct.ProjectPhoneNumberDeleteCall.html), [*phone numbers list*](struct.ProjectPhoneNumberListCall.html), [*phone numbers patch*](struct.ProjectPhoneNumberPatchCall.html) and [*phone numbers undelete*](struct.ProjectPhoneNumberUndeleteCall.html)
//! 
//! 
//! 
//! 
//! Not what you are looking for ? Find all other Google APIs in their Rust [documentation index](http://byron.github.io/google-apis-rs).
//! 
//! # Structure of this Library
//! 
//! The API is structured into the following primary items:
//! 
//! * **[Hub](struct.Dialogflow.html)**
//!     * a central object to maintain state and allow accessing all *Activities*
//!     * creates [*Method Builders*](trait.MethodsBuilder.html) which in turn
//!       allow access to individual [*Call Builders*](trait.CallBuilder.html)
//! * **[Resources](trait.Resource.html)**
//!     * primary types that you can apply *Activities* to
//!     * a collection of properties and *Parts*
//!     * **[Parts](trait.Part.html)**
//!         * a collection of properties
//!         * never directly used in *Activities*
//! * **[Activities](trait.CallBuilder.html)**
//!     * operations to apply to *Resources*
//! 
//! All *structures* are marked with applicable traits to further categorize them and ease browsing.
//! 
//! Generally speaking, you can invoke *Activities* like this:
//! 
//! ```Rust,ignore
//! let r = hub.resource().activity(...).doit()
//! ```
//! 
//! Or specifically ...
//! 
//! ```ignore
//! let r = hub.projects().agent_restore(...).doit()
//! let r = hub.projects().agent_intents_batch_delete(...).doit()
//! let r = hub.projects().knowledge_bases_documents_create(...).doit()
//! let r = hub.projects().knowledge_bases_documents_delete(...).doit()
//! let r = hub.projects().agent_entity_types_batch_delete(...).doit()
//! let r = hub.projects().agent_train(...).doit()
//! let r = hub.projects().agent_knowledge_bases_documents_delete(...).doit()
//! let r = hub.projects().agent_import(...).doit()
//! let r = hub.projects().agent_entity_types_batch_update(...).doit()
//! let r = hub.projects().agent_export(...).doit()
//! let r = hub.projects().agent_knowledge_bases_documents_create(...).doit()
//! let r = hub.projects().agent_intents_batch_update(...).doit()
//! let r = hub.projects().agent_entity_types_entities_batch_update(...).doit()
//! let r = hub.projects().agent_entity_types_entities_batch_delete(...).doit()
//! let r = hub.projects().operations_get(...).doit()
//! let r = hub.projects().agent_entity_types_entities_batch_create(...).doit()
//! ```
//! 
//! The `resource()` and `activity(...)` calls create [builders][builder-pattern]. The second one dealing with `Activities` 
//! supports various methods to configure the impending operation (not shown here). It is made such that all required arguments have to be 
//! specified right away (i.e. `(...)`), whereas all optional ones can be [build up][builder-pattern] as desired.
//! The `doit()` method performs the actual communication with the server and returns the respective result.
//! 
//! # Usage
//! 
//! ## Setting up your Project
//! 
//! To use this library, you would put the following lines into your `Cargo.toml` file:
//! 
//! ```toml
//! [dependencies]
//! google-dialogflow2_beta1 = "*"
//! # This project intentionally uses an old version of Hyper. See
//! # https://github.com/Byron/google-apis-rs/issues/173 for more
//! # information.
//! hyper = "^0.10"
//! hyper-rustls = "^0.6"
//! serde = "^1.0"
//! serde_json = "^1.0"
//! yup-oauth2 = "^1.0"
//! ```
//! 
//! ## A complete example
//! 
//! ```test_harness,no_run
//! extern crate hyper;
//! extern crate hyper_rustls;
//! extern crate yup_oauth2 as oauth2;
//! extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
//! use dialogflow2_beta1::GoogleCloudDialogflowV2beta1RestoreAgentRequest;
//! use dialogflow2_beta1::{Result, Error};
//! # #[test] fn egal() {
//! use std::default::Default;
//! use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
//! use dialogflow2_beta1::Dialogflow;
//! 
//! // Get an ApplicationSecret instance by some means. It contains the `client_id` and 
//! // `client_secret`, among other things.
//! let secret: ApplicationSecret = Default::default();
//! // Instantiate the authenticator. It will choose a suitable authentication flow for you, 
//! // unless you replace  `None` with the desired Flow.
//! // Provide your own `AuthenticatorDelegate` to adjust the way it operates and get feedback about 
//! // what's going on. You probably want to bring in your own `TokenStorage` to persist tokens and
//! // retrieve them from storage.
//! let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
//!                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
//!                               <MemoryStorage as Default>::default(), None);
//! let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
//! // As the method needs a request, you would usually fill it with the desired information
//! // into the respective structure. Some of the parts shown here might not be applicable !
//! // Values shown here are possibly random and not representative !
//! let mut req = GoogleCloudDialogflowV2beta1RestoreAgentRequest::default();
//! 
//! // You can configure optional parameters by calling the respective setters at will, and
//! // execute the final call using `doit()`.
//! // Values shown here are possibly random and not representative !
//! let result = hub.projects().agent_restore(req, "parent")
//!              .doit();
//! 
//! match result {
//!     Err(e) => match e {
//!         // The Error enum provides details about what exactly happened.
//!         // You can also just use its `Debug`, `Display` or `Error` traits
//!          Error::HttpError(_)
//!         |Error::MissingAPIKey
//!         |Error::MissingToken
//!         |Error::Cancelled
//!         |Error::UploadSizeLimitExceeded(_, _)
//!         |Error::Failure(_)
//!         |Error::BadRequest(_)
//!         |Error::FieldClash(_)
//!         |Error::JsonDecodeError(_, _) => println!("{}", e),
//!     },
//!     Ok(res) => println!("Success: {:?}", res),
//! }
//! # }
//! ```
//! ## Handling Errors
//! 
//! All errors produced by the system are provided either as [Result](enum.Result.html) enumeration as return value of 
//! the doit() methods, or handed as possibly intermediate results to either the 
//! [Hub Delegate](trait.Delegate.html), or the [Authenticator Delegate](https://docs.rs/yup-oauth2/*/yup_oauth2/trait.AuthenticatorDelegate.html).
//! 
//! When delegates handle errors or intermediate values, they may have a chance to instruct the system to retry. This 
//! makes the system potentially resilient to all kinds of errors.
//! 
//! ## Uploads and Downloads
//! If a method supports downloads, the response body, which is part of the [Result](enum.Result.html), should be
//! read by you to obtain the media.
//! If such a method also supports a [Response Result](trait.ResponseResult.html), it will return that by default.
//! You can see it as meta-data for the actual media. To trigger a media download, you will have to set up the builder by making
//! this call: `.param("alt", "media")`.
//! 
//! Methods supporting uploads can do so using up to 2 different protocols: 
//! *simple* and *resumable*. The distinctiveness of each is represented by customized 
//! `doit(...)` methods, which are then named `upload(...)` and `upload_resumable(...)` respectively.
//! 
//! ## Customization and Callbacks
//! 
//! You may alter the way an `doit()` method is called by providing a [delegate](trait.Delegate.html) to the 
//! [Method Builder](trait.CallBuilder.html) before making the final `doit()` call. 
//! Respective methods will be called to provide progress information, as well as determine whether the system should 
//! retry on failure.
//! 
//! The [delegate trait](trait.Delegate.html) is default-implemented, allowing you to customize it with minimal effort.
//! 
//! ## Optional Parts in Server-Requests
//! 
//! All structures provided by this library are made to be [enocodable](trait.RequestValue.html) and 
//! [decodable](trait.ResponseResult.html) via *json*. Optionals are used to indicate that partial requests are responses 
//! are valid.
//! Most optionals are are considered [Parts](trait.Part.html) which are identifiable by name, which will be sent to 
//! the server to indicate either the set parts of the request or the desired parts in the response.
//! 
//! ## Builder Arguments
//! 
//! Using [method builders](trait.CallBuilder.html), you are able to prepare an action call by repeatedly calling it's methods.
//! These will always take a single argument, for which the following statements are true.
//! 
//! * [PODs][wiki-pod] are handed by copy
//! * strings are passed as `&str`
//! * [request values](trait.RequestValue.html) are moved
//! 
//! Arguments will always be copied or cloned into the builder, to make them independent of their original life times.
//! 
//! [wiki-pod]: http://en.wikipedia.org/wiki/Plain_old_data_structure
//! [builder-pattern]: http://en.wikipedia.org/wiki/Builder_pattern
//! [google-go-api]: https://github.com/google/google-api-go-client
//! 
//! 

// Unused attributes happen thanks to defined, but unused structures
// We don't warn about this, as depending on the API, some data structures or facilities are never used.
// Instead of pre-determining this, we just disable the lint. It's manually tuned to not have any
// unused imports in fully featured APIs. Same with unused_mut ... .
#![allow(unused_imports, unused_mut, dead_code)]

// DO NOT EDIT !
// This file was generated automatically from 'src/mako/api/lib.rs.mako'
// DO NOT EDIT !

#[macro_use]
extern crate serde_derive;

extern crate http;
extern crate hyper;
extern crate hyper_tls;
extern crate serde;
extern crate serde_json;
extern crate yup_oauth2 as oauth2;
extern crate mime;
extern crate url;
extern crate futures;

mod cmn;

use futures::{ Future, Stream };
use futures::future::Either;
use std::collections::HashMap;
use std::cell::RefCell;
use std::borrow::BorrowMut;
use std::default::Default;
use std::collections::BTreeMap;
use serde_json as json;
use std::io;
use std::fs;
use std::mem;
use std::thread::sleep;
use std::time::Duration;

pub use cmn::{MultiPartReader, ToParts, MethodInfo, Result, Error, CallBuilder, Hub, ReadSeek, Part,
              ResponseResult, RequestValue, NestedType, Delegate, DefaultDelegate, MethodsBuilder,
              Resource, ErrorResponse, remove_json_null_values};


// ##############
// UTILITIES ###
// ############

/// Identifies the an OAuth2 authorization scope.
/// A scope is needed when requesting an
/// [authorization token](https://developers.google.com/youtube/v3/guides/authentication).
#[derive(PartialEq, Eq, Hash)]
pub enum Scope {
    /// View and manage your data across Google Cloud Platform services
    CloudPlatform,
}

impl AsRef<str> for Scope {
    fn as_ref(&self) -> &str {
        match *self {
            Scope::CloudPlatform => "https://www.googleapis.com/auth/cloud-platform",
        }
    }
}

impl Default for Scope {
    fn default() -> Scope {
        Scope::CloudPlatform
    }
}



// ########
// HUB ###
// ######

/// Central instance to access all Dialogflow related resource activities
///
/// # Examples
///
/// Instantiate a new hub
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1RestoreAgentRequest;
/// use dialogflow2_beta1::{Result, Error};
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use dialogflow2_beta1::Dialogflow;
/// 
/// // Get an ApplicationSecret instance by some means. It contains the `client_id` and 
/// // `client_secret`, among other things.
/// let secret: ApplicationSecret = Default::default();
/// // Instantiate the authenticator. It will choose a suitable authentication flow for you, 
/// // unless you replace  `None` with the desired Flow.
/// // Provide your own `AuthenticatorDelegate` to adjust the way it operates and get feedback about 
/// // what's going on. You probably want to bring in your own `TokenStorage` to persist tokens and
/// // retrieve them from storage.
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1RestoreAgentRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_restore(req, "parent")
///              .doit();
/// 
/// match result {
///     Err(e) => match e {
///         // The Error enum provides details about what exactly happened.
///         // You can also just use its `Debug`, `Display` or `Error` traits
///          Error::HttpError(_)
///         |Error::MissingAPIKey
///         |Error::MissingToken
///         |Error::Cancelled
///         |Error::UploadSizeLimitExceeded(_, _)
///         |Error::Failure(_)
///         |Error::BadRequest(_)
///         |Error::FieldClash(_)
///         |Error::JsonDecodeError(_, _) => println!("{}", e),
///     },
///     Ok(res) => println!("Success: {:?}", res),
/// }
/// # }
/// ```
pub struct Dialogflow<C, A> {
    client: RefCell<C>,
    auth: RefCell<A>,
    _user_agent: String,
    _base_url: String,
    _root_url: String,
}

impl<'a, C, A> Hub for Dialogflow<C, A> {}

impl<'a, C, A> Dialogflow<C, A>
    where  C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {

    pub fn new(client: C, authenticator: A) -> Dialogflow<C, A> {
        Dialogflow {
            client: RefCell::new(client),
            auth: RefCell::new(authenticator),
            _user_agent: "google-api-rust-client/1.0.8".to_string(),
            _base_url: "https://dialogflow.googleapis.com/".to_string(),
            _root_url: "https://dialogflow.googleapis.com/".to_string(),
        }
    }

    pub fn projects(&'a self) -> ProjectMethods<'a, C, A> {
        ProjectMethods { hub: &self }
    }

    /// Set the user-agent header field to use in all requests to the server.
    /// It defaults to `google-api-rust-client/1.0.8`.
    ///
    /// Returns the previously set user-agent.
    pub fn user_agent(&mut self, agent_name: String) -> String {
        mem::replace(&mut self._user_agent, agent_name)
    }

    /// Set the base url to use in all requests to the server.
    /// It defaults to `https://dialogflow.googleapis.com/`.
    ///
    /// Returns the previously set base url.
    pub fn base_url(&mut self, new_base_url: String) -> String {
        mem::replace(&mut self._base_url, new_base_url)
    }

    /// Set the root url to use in all requests to the server.
    /// It defaults to `https://dialogflow.googleapis.com/`.
    ///
    /// Returns the previously set root url.
    pub fn root_url(&mut self, new_root_url: String) -> String {
        mem::replace(&mut self._root_url, new_root_url)
    }
}


// ############
// SCHEMAS ###
// ##########
/// Plays audio from a file in Telephony Gateway.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageTelephonyPlayAudio {
    /// Required. URI to a Google Cloud Storage object containing the audio to
    /// play, e.g., "gs://bucket/object". The object must contain a single
    /// channel (mono) of linear PCM audio (2 bytes / sample) at 8kHz.
    /// 
    /// This object must be readable by the `service-<Project
    /// Number>@gcp-sa-dialogflow.iam.gserviceaccount.com` service account
    /// where <Project Number> is the number of the Telephony Gateway project
    /// (usually the same as the Dialogflow agent project). If the Google Cloud
    /// Storage bucket is in the Telephony Gateway project, this permission is
    /// added by default when enabling the Dialogflow V2 API.
    /// 
    /// For audio from other sources, consider using the
    /// `TelephonySynthesizeSpeech` message with SSML.
    #[serde(rename="audioUri")]
    pub audio_uri: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageTelephonyPlayAudio {}


/// Corresponds to the `Response` field in the Dialogflow console.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessage {
    /// Returns a voice or text-only response for Actions on Google.
    #[serde(rename="simpleResponses")]
    pub simple_responses: Option<GoogleCloudDialogflowV2beta1IntentMessageSimpleResponses>,
    /// Displays quick replies.
    #[serde(rename="quickReplies")]
    pub quick_replies: Option<GoogleCloudDialogflowV2beta1IntentMessageQuickReplies>,
    /// Displays a link out suggestion chip for Actions on Google.
    #[serde(rename="linkOutSuggestion")]
    pub link_out_suggestion: Option<GoogleCloudDialogflowV2beta1IntentMessageLinkOutSuggestion>,
    /// Returns a text response.
    pub text: Option<GoogleCloudDialogflowV2beta1IntentMessageText>,
    /// Displays an image.
    pub image: Option<GoogleCloudDialogflowV2beta1IntentMessageImage>,
    /// Synthesizes speech in Telephony Gateway.
    #[serde(rename="telephonySynthesizeSpeech")]
    pub telephony_synthesize_speech: Option<GoogleCloudDialogflowV2beta1IntentMessageTelephonySynthesizeSpeech>,
    /// Displays suggestion chips for Actions on Google.
    pub suggestions: Option<GoogleCloudDialogflowV2beta1IntentMessageSuggestions>,
    /// Plays audio from a file in Telephony Gateway.
    #[serde(rename="telephonyPlayAudio")]
    pub telephony_play_audio: Option<GoogleCloudDialogflowV2beta1IntentMessageTelephonyPlayAudio>,
    /// Optional. The platform that this message is intended for.
    pub platform: Option<String>,
    /// Displays a basic card for Actions on Google.
    #[serde(rename="basicCard")]
    pub basic_card: Option<GoogleCloudDialogflowV2beta1IntentMessageBasicCard>,
    /// Displays a carousel card for Actions on Google.
    #[serde(rename="carouselSelect")]
    pub carousel_select: Option<GoogleCloudDialogflowV2beta1IntentMessageCarouselSelect>,
    /// Displays a list card for Actions on Google.
    #[serde(rename="listSelect")]
    pub list_select: Option<GoogleCloudDialogflowV2beta1IntentMessageListSelect>,
    /// Transfers the call in Telephony Gateway.
    #[serde(rename="telephonyTransferCall")]
    pub telephony_transfer_call: Option<GoogleCloudDialogflowV2beta1IntentMessageTelephonyTransferCall>,
    /// Returns a response containing a custom, platform-specific payload.
    /// See the Intent.Message.Platform type for a description of the
    /// structure that may be required for your platform.
    pub payload: Option<HashMap<String, String>>,
    /// Displays a card.
    pub card: Option<GoogleCloudDialogflowV2beta1IntentMessageCard>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessage {}


/// A document resource.
/// 
/// Note: resource `projects.agent.knowledgeBases.documents` is deprecated,
/// please use `projects.knowledgeBases.documents` instead.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent knowledge bases documents get projects](struct.ProjectAgentKnowledgeBaseDocumentGetCall.html) (response)
/// * [agent knowledge bases documents create projects](struct.ProjectAgentKnowledgeBaseDocumentCreateCall.html) (request)
/// * [knowledge bases documents create projects](struct.ProjectKnowledgeBaseDocumentCreateCall.html) (request)
/// * [knowledge bases documents get projects](struct.ProjectKnowledgeBaseDocumentGetCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1Document {
    /// Required. The MIME type of this document.
    #[serde(rename="mimeType")]
    pub mime_type: Option<String>,
    /// The raw content of the document. This field is only permitted for
    /// EXTRACTIVE_QA and FAQ knowledge types.
    /// Note: This field is in the process of being deprecated, please use
    /// raw_content instead.
    pub content: Option<String>,
    /// Required. The display name of the document. The name must be 1024 bytes or
    /// less; otherwise, the creation request fails.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
    /// The document resource name.
    /// The name must be empty when creating a document.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
    /// ID>/documents/<Document ID>`.
    pub name: Option<String>,
    /// Required. The knowledge type of document content.
    #[serde(rename="knowledgeTypes")]
    pub knowledge_types: Option<Vec<String>>,
    /// The raw content of the document. This field is only permitted for
    /// EXTRACTIVE_QA and FAQ knowledge types.
    #[serde(rename="rawContent")]
    pub raw_content: Option<String>,
    /// The URI where the file content is located.
    /// 
    /// For documents stored in Google Cloud Storage, these URIs must have
    /// the form `gs://<bucket-name>/<object-name>`.
    /// 
    /// NOTE: External URLs must correspond to public webpages, i.e., they must
    /// be indexed by Google Search. In particular, URLs for showing documents in
    /// Google Cloud Storage (i.e. the URL in your browser) are not supported.
    /// Instead use the `gs://` format URI described above.
    #[serde(rename="contentUri")]
    pub content_uri: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1Document {}
impl ResponseResult for GoogleCloudDialogflowV2beta1Document {}


/// Represents a conversation.
/// A conversation is an interaction between an agent, including live agents
/// and Dialogflow agents, and a support customer. Conversations can
/// include phone calls and text-based chat sessions.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations get projects](struct.ProjectConversationGetCall.html) (response)
/// * [conversations create projects](struct.ProjectConversationCreateCall.html) (request|response)
/// * [conversations complete projects](struct.ProjectConversationCompleteCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1Conversation {
    /// Output only. The time the conversation was finished.
    #[serde(rename="endTime")]
    pub end_time: Option<String>,
    /// Output only. Required if the conversation is to be connected over
    /// telephony.
    #[serde(rename="phoneNumber")]
    pub phone_number: Option<GoogleCloudDialogflowV2beta1ConversationPhoneNumber>,
    /// The unique identifier of this conversation.
    /// Required for all methods except `create` (`create` populates the name
    /// automatically).
    /// Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    pub name: Option<String>,
    /// Output only. The time the conversation was started.
    #[serde(rename="startTime")]
    pub start_time: Option<String>,
    /// Required. The Conversation Profile to be used to configure this
    /// Conversation. This field cannot be updated.
    /// Format: `projects/<Project ID>/conversationProfiles/<Conversation Profile
    /// ID>`.
    #[serde(rename="conversationProfile")]
    pub conversation_profile: Option<String>,
    /// Output only. The current state of the Conversation.
    #[serde(rename="lifecycleState")]
    pub lifecycle_state: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1Conversation {}
impl ResponseResult for GoogleCloudDialogflowV2beta1Conversation {}


/// Represents intent parameters.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentParameter {
    /// Optional. Indicates whether the parameter is required. That is,
    /// whether the intent cannot be completed without collecting the parameter
    /// value.
    pub mandatory: Option<bool>,
    /// The unique identifier of this parameter.
    pub name: Option<String>,
    /// Optional. The default value to use when the `value` yields an empty
    /// result.
    /// Default values can be extracted from contexts by using the following
    /// syntax: `#context_name.parameter_name`.
    #[serde(rename="defaultValue")]
    pub default_value: Option<String>,
    /// Optional. The name of the entity type, prefixed with `@`, that
    /// describes values of the parameter. If the parameter is
    /// required, this must be provided.
    #[serde(rename="entityTypeDisplayName")]
    pub entity_type_display_name: Option<String>,
    /// Optional. The definition of the parameter value. It can be:
    /// - a constant string,
    /// - a parameter value defined as `$parameter_name`,
    /// - an original parameter value defined as `$parameter_name.original`,
    /// - a parameter value from some context defined as
    ///   `#context_name.parameter_name`.
    pub value: Option<String>,
    /// Optional. The collection of prompts that the agent can present to the
    /// user in order to collect value for the parameter.
    pub prompts: Option<Vec<String>>,
    /// Optional. Indicates whether the parameter represents a list of values.
    #[serde(rename="isList")]
    pub is_list: Option<bool>,
    /// Required. The name of the parameter.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentParameter {}


/// Instructs the speech synthesizer how to generate the output audio content.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1OutputAudioConfig {
    /// Required. Audio encoding of the synthesized audio content.
    #[serde(rename="audioEncoding")]
    pub audio_encoding: Option<String>,
    /// Optional. The synthesis sample rate (in hertz) for this audio. If not
    /// provided, then the synthesizer will use the default sample rate based on
    /// the audio encoding. If this is different from the voice's natural sample
    /// rate, then the synthesizer will honor this request by converting to the
    /// desired sample rate (which might result in worse audio quality).
    #[serde(rename="sampleRateHertz")]
    pub sample_rate_hertz: Option<i32>,
    /// Optional. Configuration of how speech should be synthesized.
    #[serde(rename="synthesizeSpeechConfig")]
    pub synthesize_speech_config: Option<GoogleCloudDialogflowV2beta1SynthesizeSpeechConfig>,
}

impl Part for GoogleCloudDialogflowV2beta1OutputAudioConfig {}


/// The response message for [Conversations.ListSuggestions]
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations participants suggestions list projects](struct.ProjectConversationParticipantSuggestionListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListSuggestionsResponse {
    /// Optional. Token to retrieve the next page of results or empty if there are
    /// no more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Required.
    pub suggestions: Option<Vec<GoogleCloudDialogflowV2beta1Suggestion>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListSuggestionsResponse {}


/// Represents the parameters of the conversational query.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1QueryParameters {
    /// Optional. The geo location of this conversational query.
    #[serde(rename="geoLocation")]
    pub geo_location: Option<GoogleTypeLatLng>,
    /// Optional. The collection of contexts to be activated before this query is
    /// executed.
    pub contexts: Option<Vec<GoogleCloudDialogflowV2beta1Context>>,
    /// Optional. KnowledgeBases to get alternative results from. If not set, the
    /// KnowledgeBases enabled in the agent (through UI) will be used.
    /// Format:  `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    #[serde(rename="knowledgeBaseNames")]
    pub knowledge_base_names: Option<Vec<String>>,
    /// Optional. Configures the type of sentiment analysis to perform. If not
    /// provided, sentiment analysis is not performed.
    /// Note: Sentiment Analysis is only currently available for Enterprise Edition
    /// agents.
    #[serde(rename="sentimentAnalysisRequestConfig")]
    pub sentiment_analysis_request_config: Option<GoogleCloudDialogflowV2beta1SentimentAnalysisRequestConfig>,
    /// Optional. Specifies whether to delete all contexts in the current session
    /// before the new ones are activated.
    #[serde(rename="resetContexts")]
    pub reset_contexts: Option<bool>,
    /// Optional. The time zone of this conversational query from the
    /// [time zone database](https://www.iana.org/time-zones), e.g.,
    /// America/New_York, Europe/Paris. If not provided, the time zone specified in
    /// agent settings is used.
    #[serde(rename="timeZone")]
    pub time_zone: Option<String>,
    /// Optional. This field can be used to pass custom data into the webhook
    /// associated with the agent. Arbitrary JSON objects are supported.
    pub payload: Option<HashMap<String, String>>,
    /// Optional. Additional session entity types to replace or extend developer
    /// entity types with. The entity synonyms apply to all languages and persist
    /// for the session of this query.
    #[serde(rename="sessionEntityTypes")]
    pub session_entity_types: Option<Vec<GoogleCloudDialogflowV2beta1SessionEntityType>>,
}

impl Part for GoogleCloudDialogflowV2beta1QueryParameters {}


/// The response message for Conversations.ListConversations.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations list projects](struct.ProjectConversationListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListConversationsResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of conversations. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub conversations: Option<Vec<GoogleCloudDialogflowV2beta1Conversation>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListConversationsResponse {}


/// The response message for HumanAgentAssistants.ListHumanAgentAssistants.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [human agent assistants list projects](struct.ProjectHumanAgentAssistantListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListHumanAgentAssistantsResponse {
    /// Token to retrieve the next page of results or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of project agent assistants. There is a maximum number of
    /// items returned based on the page_size field in the request.
    #[serde(rename="humanAgentAssistants")]
    pub human_agent_assistants: Option<Vec<GoogleCloudDialogflowV2beta1HumanAgentAssistant>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListHumanAgentAssistantsResponse {}


/// Represents a human agent assistant that provides suggestions to help
/// human agents to resolve customer issues. This defines the types of content
/// that the human agent assistant can present to a human agent.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [human agent assistants create projects](struct.ProjectHumanAgentAssistantCreateCall.html) (request|response)
/// * [human agent assistants get projects](struct.ProjectHumanAgentAssistantGetCall.html) (response)
/// * [human agent assistants patch projects](struct.ProjectHumanAgentAssistantPatchCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1HumanAgentAssistant {
    /// Optional. Settings for knowledge service.
    #[serde(rename="faqAnswersConfig")]
    pub faq_answers_config: Option<GoogleCloudDialogflowV2beta1FaqAnswersConfig>,
    /// Required for all methods except `create` (`create` populates the name
    /// automatically).
    /// The unique identifier of human agent assistant.
    /// Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    /// ID>`.
    pub name: Option<String>,
    /// Optional. Settings for article suggestion.
    #[serde(rename="articleSuggestionConfig")]
    pub article_suggestion_config: Option<GoogleCloudDialogflowV2beta1ArticleSuggestionConfig>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1HumanAgentAssistant {}
impl ResponseResult for GoogleCloudDialogflowV2beta1HumanAgentAssistant {}


/// The request message for Agents.TrainAgent.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent train projects](struct.ProjectAgentTrainCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1TrainAgentRequest { _never_set: Option<bool> }

impl RequestValue for GoogleCloudDialogflowV2beta1TrainAgentRequest {}


/// Represent a response from an automated agent.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1AutomatedAgentReply {
    /// Required. Response of the Dialogflow Sessions.DetectIntent call.
    #[serde(rename="detectIntentResponse")]
    pub detect_intent_response: Option<GoogleCloudDialogflowV2beta1DetectIntentResponse>,
}

impl Part for GoogleCloudDialogflowV2beta1AutomatedAgentReply {}


/// The response message for PhoneNumbers.ListPhoneNumbers.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [phone numbers list projects](struct.ProjectPhoneNumberListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListPhoneNumbersResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of `PhoneNumber` resources. There is a maximum number of items
    /// returned based on the page_size field in the request.
    #[serde(rename="phoneNumbers")]
    pub phone_numbers: Option<Vec<GoogleCloudDialogflowV2beta1PhoneNumber>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListPhoneNumbersResponse {}


/// Represents an intent.
/// Intents convert a number of user expressions or patterns into an action. An
/// action is an extraction of a user command or sentence semantics.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent intents get projects](struct.ProjectAgentIntentGetCall.html) (response)
/// * [agent intents create projects](struct.ProjectAgentIntentCreateCall.html) (request|response)
/// * [agent intents patch projects](struct.ProjectAgentIntentPatchCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1Intent {
    /// Optional. Indicates that this intent ends an interaction. Some integrations
    /// (e.g., Actions on Google or Dialogflow phone gateway) use this information
    /// to close interaction with an end user. Default is false.
    #[serde(rename="endInteraction")]
    pub end_interaction: Option<bool>,
    /// Optional. Indicates whether webhooks are enabled for the intent.
    #[serde(rename="webhookState")]
    pub webhook_state: Option<String>,
    /// Optional. The list of platforms for which the first response will be
    /// taken from among the messages assigned to the DEFAULT_PLATFORM.
    #[serde(rename="defaultResponsePlatforms")]
    pub default_response_platforms: Option<Vec<String>>,
    /// Optional. The name of the action associated with the intent.
    /// Note: The action name must not contain whitespaces.
    pub action: Option<String>,
    /// Optional. Indicates whether Machine Learning is enabled for the intent.
    /// Note: If `ml_enabled` setting is set to false, then this intent is not
    /// taken into account during inference in `ML ONLY` match mode. Also,
    /// auto-markup in the UI is turned off.
    /// DEPRECATED! Please use `ml_disabled` field instead.
    /// NOTE: If both `ml_enabled` and `ml_disabled` are either not set or false,
    /// then the default value is determined as follows:
    /// - Before April 15th, 2018 the default is:
    ///   ml_enabled = false / ml_disabled = true.
    /// - After April 15th, 2018 the default is:
    ///   ml_enabled = true / ml_disabled = false.
    #[serde(rename="mlEnabled")]
    pub ml_enabled: Option<bool>,
    /// Optional. The collection of contexts that are activated when the intent
    /// is matched. Context messages in this collection should not set the
    /// parameters field. Setting the `lifespan_count` to 0 will reset the context
    /// when the intent is matched.
    /// Format: `projects/<Project ID>/agent/sessions/-/contexts/<Context ID>`.
    #[serde(rename="outputContexts")]
    pub output_contexts: Option<Vec<GoogleCloudDialogflowV2beta1Context>>,
    /// Optional. Indicates whether this is a fallback intent.
    #[serde(rename="isFallback")]
    pub is_fallback: Option<bool>,
    /// Optional. Indicates whether Machine Learning is disabled for the intent.
    /// Note: If `ml_disabled` setting is set to true, then this intent is not
    /// taken into account during inference in `ML ONLY` match mode. Also,
    /// auto-markup in the UI is turned off.
    #[serde(rename="mlDisabled")]
    pub ml_disabled: Option<bool>,
    /// Required. The name of this intent.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
    /// Required for all methods except `create` (`create` populates the name
    /// automatically.
    /// The unique identifier of this intent.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    pub name: Option<String>,
    /// Optional. The collection of parameters associated with the intent.
    pub parameters: Option<Vec<GoogleCloudDialogflowV2beta1IntentParameter>>,
    /// Optional. The collection of examples/templates that the agent is
    /// trained on.
    #[serde(rename="trainingPhrases")]
    pub training_phrases: Option<Vec<GoogleCloudDialogflowV2beta1IntentTrainingPhrase>>,
    /// Read-only. Information about all followup intents that have this intent as
    /// a direct or indirect parent. We populate this field only in the output.
    #[serde(rename="followupIntentInfo")]
    pub followup_intent_info: Option<Vec<GoogleCloudDialogflowV2beta1IntentFollowupIntentInfo>>,
    /// Read-only after creation. The unique identifier of the parent intent in the
    /// chain of followup intents. You can set this field when creating an intent,
    /// for example with CreateIntent or BatchUpdateIntents, in order to
    /// make this intent a followup intent.
    /// 
    /// It identifies the parent followup intent.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    #[serde(rename="parentFollowupIntentName")]
    pub parent_followup_intent_name: Option<String>,
    /// Optional. The collection of rich messages corresponding to the
    /// `Response` field in the Dialogflow console.
    pub messages: Option<Vec<GoogleCloudDialogflowV2beta1IntentMessage>>,
    /// Optional. The priority of this intent. Higher numbers represent higher
    /// priorities. Zero or negative numbers mean that the intent is disabled.
    pub priority: Option<i32>,
    /// Read-only. The unique identifier of the root intent in the chain of
    /// followup intents. It identifies the correct followup intents chain for
    /// this intent. We populate this field only in the output.
    /// 
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    #[serde(rename="rootFollowupIntentName")]
    pub root_followup_intent_name: Option<String>,
    /// Optional. The list of context names required for this intent to be
    /// triggered.
    /// Format: `projects/<Project ID>/agent/sessions/-/contexts/<Context ID>`.
    #[serde(rename="inputContextNames")]
    pub input_context_names: Option<Vec<String>>,
    /// Optional. Indicates whether to delete all contexts in the current
    /// session when this intent is matched.
    #[serde(rename="resetContexts")]
    pub reset_contexts: Option<bool>,
    /// Optional. The collection of event names that trigger the intent.
    /// If the collection of input contexts is not empty, all of the contexts must
    /// be present in the active user session for an event to trigger this intent.
    pub events: Option<Vec<String>>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1Intent {}
impl ResponseResult for GoogleCloudDialogflowV2beta1Intent {}


/// The request message for EntityTypes.BatchCreateEntities.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent entity types entities batch create projects](struct.ProjectAgentEntityTypeEntityBatchCreateCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1BatchCreateEntitiesRequest {
    /// Required. The entities to create.
    pub entities: Option<Vec<GoogleCloudDialogflowV2beta1EntityTypeEntity>>,
    /// Optional. The language of entity synonyms defined in `entities`. If not
    /// specified, the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1BatchCreateEntitiesRequest {}


/// Represents an example or template that the agent is trained on.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentTrainingPhrase {
    /// Required. The collection of training phrase parts (can be annotated).
    /// Fields: `entity_type`, `alias` and `user_defined` should be populated
    /// only for the annotated parts of the training phrase.
    pub parts: Option<Vec<GoogleCloudDialogflowV2beta1IntentTrainingPhrasePart>>,
    /// Required. The type of the training phrase.
    #[serde(rename="type")]
    pub type_: Option<String>,
    /// Output only. The unique identifier of this training phrase.
    pub name: Option<String>,
    /// Optional. Indicates how many times this example or template was added to
    /// the intent. Each time a developer adds an existing sample by editing an
    /// intent or training, this counter is increased.
    #[serde(rename="timesAddedCount")]
    pub times_added_count: Option<i32>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentTrainingPhrase {}


/// An object representing a latitude/longitude pair. This is expressed as a pair
/// of doubles representing degrees latitude and degrees longitude. Unless
/// specified otherwise, this must conform to the
/// <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
/// standard</a>. Values must be within normalized ranges.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleTypeLatLng {
    /// The latitude in degrees. It must be in the range [-90.0, +90.0].
    pub latitude: Option<f64>,
    /// The longitude in degrees. It must be in the range [-180.0, +180.0].
    pub longitude: Option<f64>,
}

impl Part for GoogleTypeLatLng {}


/// The response message for Conversations.ListParticipants.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations participants list projects](struct.ProjectConversationParticipantListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListParticipantsResponse {
    /// Token to retrieve the next page of results or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of participants. There is a maximum number of items
    /// returned based on the page_size field in the request.
    pub participants: Option<Vec<GoogleCloudDialogflowV2beta1Participant>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListParticipantsResponse {}


/// This message is a wrapper around a collection of entity types.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1EntityTypeBatch {
    /// A collection of entity types.
    #[serde(rename="entityTypes")]
    pub entity_types: Option<Vec<GoogleCloudDialogflowV2beta1EntityType>>,
}

impl Part for GoogleCloudDialogflowV2beta1EntityTypeBatch {}


/// The request to detect user's intent.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent environments users sessions detect intent projects](struct.ProjectAgentEnvironmentUserSessionDetectIntentCall.html) (request)
/// * [agent sessions detect intent projects](struct.ProjectAgentSessionDetectIntentCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1DetectIntentRequest {
    /// Optional. Instructs the speech synthesizer how to generate the output
    /// audio. If this field is not set and agent-level speech synthesizer is not
    /// configured, no output audio is generated.
    #[serde(rename="outputAudioConfig")]
    pub output_audio_config: Option<GoogleCloudDialogflowV2beta1OutputAudioConfig>,
    /// Optional. The natural language speech audio to be processed. This field
    /// should be populated iff `query_input` is set to an input audio config.
    /// A single request can contain up to 1 minute of speech audio data.
    #[serde(rename="inputAudio")]
    pub input_audio: Option<String>,
    /// Required. The input specification. It can be set to:
    /// 
    /// 1.  an audio config
    ///     which instructs the speech recognizer how to process the speech audio,
    /// 
    /// 2.  a conversational query in the form of text, or
    /// 
    /// 3.  an event that specifies which intent to trigger.
    #[serde(rename="queryInput")]
    pub query_input: Option<GoogleCloudDialogflowV2beta1QueryInput>,
    /// Optional. The parameters of this query.
    #[serde(rename="queryParams")]
    pub query_params: Option<GoogleCloudDialogflowV2beta1QueryParameters>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1DetectIntentRequest {}


/// Defines logging behavior for conversation lifecycle events.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1LoggingConfig { _never_set: Option<bool> }

impl Part for GoogleCloudDialogflowV2beta1LoggingConfig {}


/// The request message for PhoneNumbers.UndeletePhoneNumber.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [phone numbers undelete projects](struct.ProjectPhoneNumberUndeleteCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1UndeletePhoneNumberRequest { _never_set: Option<bool> }

impl RequestValue for GoogleCloudDialogflowV2beta1UndeletePhoneNumberRequest {}


/// Represents a suggestion for a human agent.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1Suggestion {
    /// Output only. Articles ordered by score in descending order.
    pub articles: Option<Vec<GoogleCloudDialogflowV2beta1SuggestionArticle>>,
    /// Optional. Answers extracted from FAQ documents.
    #[serde(rename="faqAnswers")]
    pub faq_answers: Option<Vec<GoogleCloudDialogflowV2beta1SuggestionFaqAnswer>>,
    /// Output only. The name of this suggestion. Format:
    /// `projects/<Project ID>/conversations/<Conversation
    /// ID>/participants/*/suggestions/<Suggestion ID>`.
    pub name: Option<String>,
    /// Output only. The time the suggestion was created.
    #[serde(rename="createTime")]
    pub create_time: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1Suggestion {}


/// Contains a speech recognition result corresponding to a portion of the audio
/// that is currently being processed or an indication that this is the end
/// of the single requested utterance.
/// 
/// Example:
/// 
/// 1.  transcript: "tube"
/// 
/// 2.  transcript: "to be a"
/// 
/// 3.  transcript: "to be"
/// 
/// 4.  transcript: "to be or not to be"
///     is_final: true
/// 
/// 5.  transcript: " that's"
/// 
/// 6.  transcript: " that is"
/// 
/// 7.  recognition_event_type: `RECOGNITION_EVENT_END_OF_SINGLE_UTTERANCE`
/// 
/// 8.  transcript: " that is the question"
///     is_final: true
/// 
/// Only two of the responses contain final results (#4 and #8 indicated by
/// `is_final: true`). Concatenating these generates the full transcript: "to be
/// or not to be that is the question".
/// 
/// In each response we populate:
/// 
/// *  for `MESSAGE_TYPE_TRANSCRIPT`: `transcript` and possibly `is_final`.
/// 
/// *  for `MESSAGE_TYPE_END_OF_SINGLE_UTTERANCE`: only `event_type`.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1StreamingRecognitionResult {
    /// The Speech confidence between 0.0 and 1.0 for the current portion of audio.
    /// A higher number indicates an estimated greater likelihood that the
    /// recognized words are correct. The default of 0.0 is a sentinel value
    /// indicating that confidence was not set.
    /// 
    /// This field is typically only provided if `is_final` is true and you should
    /// not rely on it being accurate or even set.
    pub confidence: Option<f32>,
    /// Transcript text representing the words that the user spoke.
    /// Populated if and only if `event_type` = `RECOGNITION_EVENT_TRANSCRIPT`.
    pub transcript: Option<String>,
    /// Type of the result message.
    #[serde(rename="messageType")]
    pub message_type: Option<String>,
    /// The default of 0.0 is a sentinel value indicating `confidence` was not set.
    /// If `false`, the `StreamingRecognitionResult` represents an
    /// interim result that may change. If `true`, the recognizer will not return
    /// any further hypotheses about this piece of the audio. May only be populated
    /// for `event_type` = `RECOGNITION_EVENT_TRANSCRIPT`.
    #[serde(rename="isFinal")]
    pub is_final: Option<bool>,
}

impl Part for GoogleCloudDialogflowV2beta1StreamingRecognitionResult {}


/// Represents a single side of the conversation.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations participants get projects](struct.ProjectConversationParticipantGetCall.html) (response)
/// * [conversations participants create projects](struct.ProjectConversationParticipantCreateCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1Participant {
    /// Required. The role this participant plays in the conversation.
    pub role: Option<String>,
    /// Required. The unique identifier of this participant.
    /// Format: `projects/<Project ID>/conversations/<Conversation
    /// ID>/participants/<Participant ID>`.
    pub name: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1Participant {}
impl ResponseResult for GoogleCloudDialogflowV2beta1Participant {}


/// The card response message.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageCard {
    /// Optional. The collection of card buttons.
    pub buttons: Option<Vec<GoogleCloudDialogflowV2beta1IntentMessageCardButton>>,
    /// Optional. The public URI to an image file for the card.
    #[serde(rename="imageUri")]
    pub image_uri: Option<String>,
    /// Optional. The subtitle of the card.
    pub subtitle: Option<String>,
    /// Optional. The title of the card.
    pub title: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageCard {}


/// The response message for
/// HumanAgentAssistants.RequestCompileSuggestions
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [human agent assistants compile suggestions projects](struct.ProjectHumanAgentAssistantCompileSuggestionCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1CompileSuggestionsResponse {
    /// Required.
    pub suggestions: Option<Vec<GoogleCloudDialogflowV2beta1Suggestion>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1CompileSuggestionsResponse {}


/// Defines article suggestions that a human agent assistant can provide.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ArticleSuggestionConfig {
    /// Required. Settings for knowledge base, Format:
    /// `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    #[serde(rename="knowledgeBaseName")]
    pub knowledge_base_name: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1ArticleSuggestionConfig {}


/// The card for presenting a carousel of options to select from.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageCarouselSelect {
    /// Required. Carousel items.
    pub items: Option<Vec<GoogleCloudDialogflowV2beta1IntentMessageCarouselSelectItem>>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageCarouselSelect {}


/// Additional info about the select item for when it is triggered in a
/// dialog.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageSelectItemInfo {
    /// Optional. A list of synonyms that can also be used to trigger this
    /// item in dialog.
    pub synonyms: Option<Vec<String>>,
    /// Required. A unique key that will be sent back to the agent if this
    /// response is given.
    pub key: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageSelectItemInfo {}


/// The response message for ConversationProfiles.ListConversationProfiles.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversation profiles list projects](struct.ProjectConversationProfileListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListConversationProfilesResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of project conversation profiles. There is a maximum number
    /// of items returned based on the page_size field in the request.
    #[serde(rename="conversationProfiles")]
    pub conversation_profiles: Option<Vec<GoogleCloudDialogflowV2beta1ConversationProfile>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListConversationProfilesResponse {}


/// The request message for Agents.ExportAgent.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent export projects](struct.ProjectAgentExportCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ExportAgentRequest {
    /// Optional. The
    /// [Google Cloud Storage](https://cloud.google.com/storage/docs/)
    /// URI to export the agent to.
    /// The format of this URI must be `gs://<bucket-name>/<object-name>`.
    /// If left unspecified, the serialized agent is returned inline.
    #[serde(rename="agentUri")]
    pub agent_uri: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1ExportAgentRequest {}


/// Defines the Automated Agent to connect to a conversation.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1AutomatedAgentConfig {
    /// Required. ID of the Dialogflow agent environment to use.
    /// 
    /// This project needs to either be the same project as the conversation or you
    /// need to grant `service-<Conversation Project
    /// Number>@gcp-sa-dialogflow.iam.gserviceaccount.com` the `Dialogflow API
    /// Service Agent` role in this project.
    /// 
    /// Format: `projects/<Project ID>/agent/environments/<Environment ID or '-'>`
    /// If environment is not specified, the default `draft` environment is
    /// used. Refer to
    /// [DetectIntentRequest](/dialogflow-enterprise/docs/reference/rpc/google.cloud.dialogflow.v2beta1#google.cloud.dialogflow.v2beta1.DetectIntentRequest)
    /// for more details.
    pub agent: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1AutomatedAgentConfig {}


/// The request message for Conversations.AnalyzeContent.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations participants analyze content projects](struct.ProjectConversationParticipantAnalyzeContentCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1AnalyzeContentRequest {
    /// Optional. Instructs the speech synthesizer how to generate the output
    /// audio.
    #[serde(rename="replyAudioConfig")]
    pub reply_audio_config: Option<GoogleCloudDialogflowV2beta1OutputAudioConfig>,
    /// The natural language text to be processed.
    pub text: Option<GoogleCloudDialogflowV2beta1InputText>,
    /// The natural language speech audio to be processed.
    pub audio: Option<GoogleCloudDialogflowV2beta1InputAudio>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1AnalyzeContentRequest {}


/// The top-level message returned from the `StreamingAnalyzeContent` method.
/// 
/// Multiple response messages can be returned in order:
/// 
/// 1.  If the input was set to streaming audio, the first one or more messages
///     contain `recognition_result`. Each `recognition_result` represents a more
///     complete transcript of what the user said. The last `recognition_result`
///     has `is_final` set to `true`.
/// 
/// 2.  The next message contains `reply_text` and optionally `reply_audio`
///     returned by an agent. This message may also contain
///     `automated_agent_reply`.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations participants streaming analyze content projects](struct.ProjectConversationParticipantStreamingAnalyzeContentCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1StreamingAnalyzeContentResponse {
    /// Optional. The output text content.
    /// This field is set if an automated agent responded with a text for the user.
    #[serde(rename="replyText")]
    pub reply_text: Option<String>,
    /// Optional. The audio data bytes encoded as specified in the request.
    /// This field is set if:
    ///  - The `reply_audio_config` field is specified in the request.
    ///  - The automated agent, which this output comes from, responded with audio.
    ///    In such case, the `reply_audio.config` field contains settings used to
    ///    synthesize the speech.
    #[serde(rename="replyAudio")]
    pub reply_audio: Option<GoogleCloudDialogflowV2beta1OutputAudio>,
    /// The result of speech recognition.
    #[serde(rename="recognitionResult")]
    pub recognition_result: Option<GoogleCloudDialogflowV2beta1StreamingRecognitionResult>,
    /// Optional. Only set if a Dialogflow automated agent has responded.
    #[serde(rename="automatedAgentReply")]
    pub automated_agent_reply: Option<GoogleCloudDialogflowV2beta1AutomatedAgentReply>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1StreamingAnalyzeContentResponse {}


/// The response message for EntityTypes.ListEntityTypes.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent entity types list projects](struct.ProjectAgentEntityTypeListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListEntityTypesResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of agent entity types. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    #[serde(rename="entityTypes")]
    pub entity_types: Option<Vec<GoogleCloudDialogflowV2beta1EntityType>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListEntityTypesResponse {}


/// The request message for EntityTypes.BatchDeleteEntityTypes.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent entity types batch delete projects](struct.ProjectAgentEntityTypeBatchDeleteCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1BatchDeleteEntityTypesRequest {
    /// Required. The names entity types to delete. All names must point to the
    /// same agent as `parent`.
    #[serde(rename="entityTypeNames")]
    pub entity_type_names: Option<Vec<String>>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1BatchDeleteEntityTypesRequest {}


/// Defines FAQ responses that a human agent assistant can provide.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1FaqAnswersConfig {
    /// Optional. Maximum number of results to return. If unset, defaults to 10.
    #[serde(rename="maxResults")]
    pub max_results: Option<i32>,
    /// Required. Settings for knowledge base, Format:
    /// `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    #[serde(rename="knowledgeBaseName")]
    pub knowledge_base_name: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1FaqAnswersConfig {}


/// Opens the given URI.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageBasicCardButtonOpenUriAction {
    /// Required. The HTTP or HTTPS scheme URI.
    pub uri: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageBasicCardButtonOpenUriAction {}


/// The request message for Conversations.AddConversationPhoneNumber.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations add conversation phone number projects](struct.ProjectConversationAddConversationPhoneNumberCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1AddConversationPhoneNumberRequest { _never_set: Option<bool> }

impl RequestValue for GoogleCloudDialogflowV2beta1AddConversationPhoneNumberRequest {}


/// Represents the query input. It can contain either:
/// 
/// 1.  An audio config which
///     instructs the speech recognizer how to process the speech audio.
/// 
/// 2.  A conversational query in the form of text,.
/// 
/// 3.  An event that specifies which intent to trigger.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1QueryInput {
    /// The natural language text to be processed.
    pub text: Option<GoogleCloudDialogflowV2beta1TextInput>,
    /// The event to be processed.
    pub event: Option<GoogleCloudDialogflowV2beta1EventInput>,
    /// Instructs the speech recognizer how to process the speech audio.
    #[serde(rename="audioConfig")]
    pub audio_config: Option<GoogleCloudDialogflowV2beta1InputAudioConfig>,
}

impl Part for GoogleCloudDialogflowV2beta1QueryInput {}


/// Represents a message posted into a conversation.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1Message {
    /// Required. The message content.
    pub content: Option<String>,
    /// Required. The message language.
    /// This should be a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
    /// language tag. Example: "en-US".
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// Required. The participant that said this message.
    pub participant: Option<String>,
    /// Required. The unique identifier of the message.
    /// Format: `projects/<Project ID>/conversations/<Conversation
    /// ID>/messages/<Message ID>`.
    pub name: Option<String>,
    /// Optional. The role of the participant.
    #[serde(rename="participantRole")]
    pub participant_role: Option<String>,
    /// Optional. The time when the message was sent.
    #[serde(rename="createTime")]
    pub create_time: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1Message {}


/// The request message for Agents.ImportAgent.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent import projects](struct.ProjectAgentImportCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ImportAgentRequest {
    /// The URI to a Google Cloud Storage file containing the agent to import.
    /// Note: The URI must start with "gs://".
    #[serde(rename="agentUri")]
    pub agent_uri: Option<String>,
    /// The agent to import.
    /// 
    /// Example for how to import an agent via the command line:
    /// <pre>curl \
    ///   'https://dialogflow.googleapis.com/v2beta1/projects/&lt;project_name&gt;/agent:import\
    ///    -X POST \
    ///    -H 'Authorization: Bearer '$(gcloud auth application-default
    ///    print-access-token) \
    ///    -H 'Accept: application/json' \
    ///    -H 'Content-Type: application/json' \
    ///    --compressed \
    ///    --data-binary "{
    ///       'agentContent': '$(cat &lt;agent zip file&gt; | base64 -w 0)'
    ///    }"</pre>
    #[serde(rename="agentContent")]
    pub agent_content: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1ImportAgentRequest {}


/// Represents a phone number for telephony integration. It allows for connecting
/// a particular conversation over telephony.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations add conversation phone number projects](struct.ProjectConversationAddConversationPhoneNumberCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ConversationPhoneNumber {
    /// Output only. The phone number to connect to this conversation.
    #[serde(rename="phoneNumber")]
    pub phone_number: Option<String>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ConversationPhoneNumber {}


/// Configuration of how speech should be synthesized.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1SynthesizeSpeechConfig {
    /// Optional. An identifier which selects 'audio effects' profiles that are
    /// applied on (post synthesized) text to speech. Effects are applied on top of
    /// each other in the order they are given.
    #[serde(rename="effectsProfileId")]
    pub effects_profile_id: Option<Vec<String>>,
    /// Optional. The desired voice of the synthesized audio.
    pub voice: Option<GoogleCloudDialogflowV2beta1VoiceSelectionParams>,
    /// Optional. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal
    /// native speed supported by the specific voice. 2.0 is twice as fast, and
    /// 0.5 is half as fast. If unset(0.0), defaults to the native 1.0 speed. Any
    /// other values < 0.25 or > 4.0 will return an error.
    #[serde(rename="speakingRate")]
    pub speaking_rate: Option<f64>,
    /// Optional. Volume gain (in dB) of the normal native volume supported by the
    /// specific voice, in the range [-96.0, 16.0]. If unset, or set to a value of
    /// 0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
    /// will play at approximately half the amplitude of the normal native signal
    /// amplitude. A value of +6.0 (dB) will play at approximately twice the
    /// amplitude of the normal native signal amplitude. We strongly recommend not
    /// to exceed +10 (dB) as there's usually no effective increase in loudness for
    /// any value greater than that.
    #[serde(rename="volumeGainDb")]
    pub volume_gain_db: Option<f64>,
    /// Optional. Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20
    /// semitones from the original pitch. -20 means decrease 20 semitones from the
    /// original pitch.
    pub pitch: Option<f64>,
}

impl Part for GoogleCloudDialogflowV2beta1SynthesizeSpeechConfig {}


/// Defines notification behavior for conversation lifecycle events.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1NotificationConfig {
    /// Optional. Name of the Cloud Pub/Sub topic to publish conversation
    /// events like
    /// CONVERSATION_STARTED as
    /// serialized ConversationEvent protos.
    /// 
    /// If enable_notifications is
    /// `true` and no topic is supplied, a new topic is created and listed
    /// here.
    /// 
    /// Notification works for phone calls, if this topic either is in the same
    /// project as the conversation or you grant `service-<Conversation Project
    /// Number>@gcp-sa-dialogflow.iam.gserviceaccount.com` the `Dialogflow Service
    /// Agent` role in the topic project.
    /// 
    /// Format: `projects/<Project ID>/topics/<Topic ID>`.
    pub topic: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1NotificationConfig {}


/// Represents the result of querying a Knowledge base.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1KnowledgeAnswers {
    /// A list of answers from Knowledge Connector.
    pub answers: Option<Vec<GoogleCloudDialogflowV2beta1KnowledgeAnswersAnswer>>,
}

impl Part for GoogleCloudDialogflowV2beta1KnowledgeAnswers {}


/// Represents a session entity type.
/// 
/// Extends or replaces a developer entity type at the user session level (we
/// refer to the entity types defined at the agent level as "developer entity
/// types").
/// 
/// Note: session entity types apply to all queries, regardless of the language.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent environments users sessions entity types get projects](struct.ProjectAgentEnvironmentUserSessionEntityTypeGetCall.html) (response)
/// * [agent environments users sessions entity types create projects](struct.ProjectAgentEnvironmentUserSessionEntityTypeCreateCall.html) (request|response)
/// * [agent environments users sessions entity types patch projects](struct.ProjectAgentEnvironmentUserSessionEntityTypePatchCall.html) (request|response)
/// * [agent sessions entity types patch projects](struct.ProjectAgentSessionEntityTypePatchCall.html) (request|response)
/// * [agent sessions entity types create projects](struct.ProjectAgentSessionEntityTypeCreateCall.html) (request|response)
/// * [agent sessions entity types get projects](struct.ProjectAgentSessionEntityTypeGetCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1SessionEntityType {
    /// Required. The collection of entities associated with this session entity
    /// type.
    pub entities: Option<Vec<GoogleCloudDialogflowV2beta1EntityTypeEntity>>,
    /// Required. The unique identifier of this session entity type. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>`, or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/entityTypes/<Entity Type Display Name>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    /// 
    /// `<Entity Type Display Name>` must be the display name of an existing entity
    /// type in the same agent that will be overridden or supplemented.
    pub name: Option<String>,
    /// Required. Indicates whether the additional data should override or
    /// supplement the developer entity type definition.
    #[serde(rename="entityOverrideMode")]
    pub entity_override_mode: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1SessionEntityType {}
impl ResponseResult for GoogleCloudDialogflowV2beta1SessionEntityType {}


/// An item in the carousel.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageCarouselSelectItem {
    /// Required. Additional info about the option item.
    pub info: Option<GoogleCloudDialogflowV2beta1IntentMessageSelectItemInfo>,
    /// Optional. The image to display.
    pub image: Option<GoogleCloudDialogflowV2beta1IntentMessageImage>,
    /// Optional. The body text of the card.
    pub description: Option<String>,
    /// Required. Title of the carousel item.
    pub title: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageCarouselSelectItem {}


/// Represents a phone number.
/// `PhoneNumber` resources enable phone calls to be answered by Dialogflow
/// services and are added to a project through a `PhoneNumberOrder`.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [phone numbers patch projects](struct.ProjectPhoneNumberPatchCall.html) (request|response)
/// * [phone numbers delete projects](struct.ProjectPhoneNumberDeleteCall.html) (response)
/// * [phone numbers undelete projects](struct.ProjectPhoneNumberUndeleteCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1PhoneNumber {
    /// Optional. The conversation profile calls to this `PhoneNumber` should use.
    /// Format: `projects/<Project ID>/conversationProfiles/<ConversationProfile
    /// ID>`.
    #[serde(rename="conversationProfile")]
    pub conversation_profile: Option<String>,
    /// Output only. Phone number in [E.164](https://en.wikipedia.org/wiki/E.164)
    /// format. An example of a correctly formatted phone number: +15556767888.
    #[serde(rename="phoneNumber")]
    pub phone_number: Option<String>,
    /// Output only. The state of the `PhoneNumber`. Defaults to `ACTIVE`.
    /// `PhoneNumber` objects set to `DELETE_REQUESTED` always decline incoming
    /// calls and can be removed completely within 30 days.
    #[serde(rename="lifecycleState")]
    pub lifecycle_state: Option<String>,
    /// Required. The unique identifier of this phone number.
    /// Format: `projects/<Project ID>/phoneNumbers/<PhoneNumber ID>`.
    pub name: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1PhoneNumber {}
impl ResponseResult for GoogleCloudDialogflowV2beta1PhoneNumber {}


/// The request message for EntityTypes.BatchDeleteEntities.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent entity types entities batch delete projects](struct.ProjectAgentEntityTypeEntityBatchDeleteCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1BatchDeleteEntitiesRequest {
    /// Optional. The language of entity synonyms defined in `entities`. If not
    /// specified, the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// Required. The canonical `values` of the entities to delete. Note that
    /// these are not fully-qualified names, i.e. they don't start with
    /// `projects/<Project ID>`.
    #[serde(rename="entityValues")]
    pub entity_values: Option<Vec<String>>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1BatchDeleteEntitiesRequest {}


/// Represents a single followup intent in the chain.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentFollowupIntentInfo {
    /// The unique identifier of the followup intent.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    #[serde(rename="followupIntentName")]
    pub followup_intent_name: Option<String>,
    /// The unique identifier of the followup intent's parent.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    #[serde(rename="parentFollowupIntentName")]
    pub parent_followup_intent_name: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentFollowupIntentInfo {}


/// Events allow for matching intents by event name instead of the natural
/// language input. For instance, input `<event: { name: “welcome_event”,
/// parameters: { name: “Sam” } }>` can trigger a personalized welcome response.
/// The parameter `name` may be used by the agent in the response:
/// `“Hello #welcome_event.name! What can I do for you today?”`.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1EventInput {
    /// Required. The language of this query. See [Language
    /// Support](https://dialogflow.com/docs/languages) for a list of the
    /// currently supported language codes. Note that queries in the same session
    /// do not necessarily need to specify the same language.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// Required. The unique identifier of the event.
    pub name: Option<String>,
    /// Optional. The collection of parameters associated with the event.
    pub parameters: Option<HashMap<String, String>>,
}

impl Part for GoogleCloudDialogflowV2beta1EventInput {}


/// Represents a conversational agent.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [get agent projects](struct.ProjectGetAgentCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1Agent {
    /// Optional. The URI of the agent's avatar.
    /// Avatars are used throughout the Dialogflow console and in the self-hosted
    /// [Web Demo](https://dialogflow.com/docs/integrations/web-demo) integration.
    #[serde(rename="avatarUri")]
    pub avatar_uri: Option<String>,
    /// Required. The name of this agent.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
    /// Optional. The description of this agent.
    /// The maximum length is 500 characters. If exceeded, the request is rejected.
    pub description: Option<String>,
    /// Required. The project of this agent.
    /// Format: `projects/<Project ID>`.
    pub parent: Option<String>,
    /// Required. The default language of the agent as a language tag. See
    /// [Language Support](https://dialogflow.com/docs/reference/language) for a
    /// list of the currently supported language codes.
    /// This field cannot be set by the `Update` method.
    #[serde(rename="defaultLanguageCode")]
    pub default_language_code: Option<String>,
    /// Optional. Determines whether this agent should log conversation queries.
    #[serde(rename="enableLogging")]
    pub enable_logging: Option<bool>,
    /// Optional. Determines how intents are detected from user queries.
    #[serde(rename="matchMode")]
    pub match_mode: Option<String>,
    /// Optional. The list of all languages supported by this agent (except for the
    /// `default_language_code`).
    #[serde(rename="supportedLanguageCodes")]
    pub supported_language_codes: Option<Vec<String>>,
    /// Required. The time zone of this agent from the
    /// [time zone database](https://www.iana.org/time-zones), e.g.,
    /// America/New_York, Europe/Paris.
    #[serde(rename="timeZone")]
    pub time_zone: Option<String>,
    /// Optional. To filter out false positive results and still get variety in
    /// matched natural language inputs for your agent, you can tune the machine
    /// learning classification threshold. If the returned score value is less than
    /// the threshold value, then a fallback intent is be triggered or, if there
    /// are no fallback intents defined, no intent will be triggered. The score
    /// values range from 0.0 (completely uncertain) to 1.0 (completely certain).
    /// If set to 0.0, the default of 0.3 is used.
    #[serde(rename="classificationThreshold")]
    pub classification_threshold: Option<f32>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1Agent {}


/// The response message for Conversations.ListMessages.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations messages list projects](struct.ProjectConversationMessageListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListMessagesResponse {
    /// Optional. Token to retrieve the next page of results, or empty if there are
    /// no more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// Required. The list of messages. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub messages: Option<Vec<GoogleCloudDialogflowV2beta1Message>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListMessagesResponse {}


/// The top-level message sent by the client to the `StreamingAnalyzeContent`
/// method.
/// 
/// Multiple request messages must be sent in the following order:
/// 
/// 1.  The first message must contain `participant` and `config` fields. To
///     receive an audio response, the first message must also contain the
///     `reply_audio_config` field. The first message must not contain `input`.
/// 
/// 2.  All subsequent messages must contain only input data. Specifically:
///     - If the `config` in the first message was set to `audio_config`, then
///       all subsequent messages must contain only `input_audio`. It is a good
///       practice to split the input audio into short chunks and deliver each
///       chunk in a separate message.
///     - If the `config` in the first message was set to `text_config`, then
///       the second message must contain only `input_text`. Moreover, the
///       `input_text` field can be only sent once.
///     After all input is delivered, the client must half-close, or abort the
///     request stream.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations participants streaming analyze content projects](struct.ProjectConversationParticipantStreamingAnalyzeContentCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1StreamingAnalyzeContentRequest {
    /// The UTF-8 encoded natural language text to be processed. Must be sent if
    /// `text_config` is set in the first message. Text length must not exceed
    /// 256 bytes. The `input_text` field can be only sent once.
    #[serde(rename="inputText")]
    pub input_text: Option<String>,
    /// Optional. Instructs the speech synthesizer how to generate the output
    /// audio.
    #[serde(rename="replyAudioConfig")]
    pub reply_audio_config: Option<GoogleCloudDialogflowV2beta1OutputAudioConfig>,
    /// The input audio content to be recognized. Must be sent if `audio_config`
    /// is set in the first message. The complete audio over all streaming
    /// messages must not exceed 1 minute.
    #[serde(rename="inputAudio")]
    pub input_audio: Option<String>,
    /// The natural language text to be processed.
    #[serde(rename="textConfig")]
    pub text_config: Option<GoogleCloudDialogflowV2beta1InputTextConfig>,
    /// Instructs the speech recognizer how to process the speech audio.
    #[serde(rename="audioConfig")]
    pub audio_config: Option<GoogleCloudDialogflowV2beta1InputAudioConfig>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1StreamingAnalyzeContentRequest {}


/// The result of sentiment analysis as configured by
/// `sentiment_analysis_request_config`.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1SentimentAnalysisResult {
    /// The sentiment analysis result for `query_text`.
    #[serde(rename="queryTextSentiment")]
    pub query_text_sentiment: Option<GoogleCloudDialogflowV2beta1Sentiment>,
}

impl Part for GoogleCloudDialogflowV2beta1SentimentAnalysisResult {}


/// Represents the natural language text to be processed.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1InputText {
    /// Required. The UTF-8 encoded natural language text to be processed.
    /// Text length must not exceed 256 bytes.
    pub text: Option<String>,
    /// Required. The language of this conversational query. See [Language
    /// Support](https://dialogflow.com/docs/languages) for a list of the
    /// currently supported language codes.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1InputText {}


/// The image response message.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageImage {
    /// A text description of the image to be used for accessibility,
    /// e.g., screen readers. Required if image_uri is set for CarouselSelect.
    #[serde(rename="accessibilityText")]
    pub accessibility_text: Option<String>,
    /// Optional. The public URI to an image file.
    #[serde(rename="imageUri")]
    pub image_uri: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageImage {}


/// The request message for EntityTypes.BatchUpdateEntityTypes.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent entity types batch update projects](struct.ProjectAgentEntityTypeBatchUpdateCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1BatchUpdateEntityTypesRequest {
    /// Optional. The language of entity synonyms defined in `entity_types`. If not
    /// specified, the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// Optional. The mask to control which fields get updated.
    #[serde(rename="updateMask")]
    pub update_mask: Option<String>,
    /// The URI to a Google Cloud Storage file containing entity types to update
    /// or create. The file format can either be a serialized proto (of
    /// EntityBatch type) or a JSON object. Note: The URI must start with
    /// "gs://".
    #[serde(rename="entityTypeBatchUri")]
    pub entity_type_batch_uri: Option<String>,
    /// The collection of entity types to update or create.
    #[serde(rename="entityTypeBatchInline")]
    pub entity_type_batch_inline: Option<GoogleCloudDialogflowV2beta1EntityTypeBatch>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1BatchUpdateEntityTypesRequest {}


/// An answer from Knowledge Connector.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1KnowledgeAnswersAnswer {
    /// The piece of text from the `source` knowledge base document that answers
    /// this conversational query.
    pub answer: Option<String>,
    /// Indicates which Knowledge Document this answer was extracted from.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
    /// ID>/documents/<Document ID>`.
    pub source: Option<String>,
    /// The system's confidence level that this knowledge answer is a good match
    /// for this conversational query.
    /// NOTE: The confidence level for a given `<query, answer>` pair may change
    /// without notice, as it depends on models that are constantly being
    /// improved. However, it will change less frequently than the confidence
    /// score below, and should be preferred for referencing the quality of an
    /// answer.
    #[serde(rename="matchConfidenceLevel")]
    pub match_confidence_level: Option<String>,
    /// The system's confidence score that this Knowledge answer is a good match
    /// for this converstational query, range from 0.0 (completely uncertain)
    /// to 1.0 (completely certain).
    /// Note: The confidence score is likely to vary somewhat (possibly even for
    /// identical requests), as the underlying model is under constant
    /// improvement, we may deprecate it in the future. We recommend using
    /// `match_confidence_level` which should be generally more stable.
    #[serde(rename="matchConfidence")]
    pub match_confidence: Option<f32>,
    /// The corresponding FAQ question if the answer was extracted from a FAQ
    /// Document, empty otherwise.
    #[serde(rename="faqQuestion")]
    pub faq_question: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1KnowledgeAnswersAnswer {}


/// Represents knowledge base resource.
/// 
/// Note: resource `projects.agent.knowledgeBases` is deprecated, please use
/// `projects.knowledgeBases` instead.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent knowledge bases create projects](struct.ProjectAgentKnowledgeBaseCreateCall.html) (request|response)
/// * [knowledge bases create projects](struct.ProjectKnowledgeBaseCreateCall.html) (request|response)
/// * [knowledge bases get projects](struct.ProjectKnowledgeBaseGetCall.html) (response)
/// * [agent knowledge bases get projects](struct.ProjectAgentKnowledgeBaseGetCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1KnowledgeBase {
    /// Required. The display name of the knowledge base. The name must be 1024
    /// bytes or less; otherwise, the creation request fails.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
    /// The knowledge base resource name.
    /// The name must be empty when creating a knowledge base.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    pub name: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1KnowledgeBase {}
impl ResponseResult for GoogleCloudDialogflowV2beta1KnowledgeBase {}


/// Response message for Documents.ListDocuments.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent knowledge bases documents list projects](struct.ProjectAgentKnowledgeBaseDocumentListCall.html) (response)
/// * [knowledge bases documents list projects](struct.ProjectKnowledgeBaseDocumentListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListDocumentsResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of documents.
    pub documents: Option<Vec<GoogleCloudDialogflowV2beta1Document>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListDocumentsResponse {}


/// Defines the Human Agent Assistant to connect to a conversation.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1HumanAgentAssistantConfig {
    /// Optional. Pub/Sub topic on which to publish new agent assistant events.
    #[serde(rename="notificationConfig")]
    pub notification_config: Option<GoogleCloudDialogflowV2beta1NotificationConfig>,
    /// Required. ID of the agent assistant to use.
    /// Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    /// ID>`.
    pub name: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1HumanAgentAssistantConfig {}


/// This message is a wrapper around a collection of intents.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentBatch {
    /// A collection of intents.
    pub intents: Option<Vec<GoogleCloudDialogflowV2beta1Intent>>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentBatch {}


/// The collection of suggestions.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageSuggestions {
    /// Required. The list of suggested replies.
    pub suggestions: Option<Vec<GoogleCloudDialogflowV2beta1IntentMessageSuggestion>>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageSuggestions {}


/// Configures the types of sentiment analysis to perform.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1SentimentAnalysisRequestConfig {
    /// Optional. Instructs the service to perform sentiment analysis on
    /// `query_text`. If not provided, sentiment analysis is not performed on
    /// `query_text`.
    #[serde(rename="analyzeQueryTextSentiment")]
    pub analyze_query_text_sentiment: Option<bool>,
}

impl Part for GoogleCloudDialogflowV2beta1SentimentAnalysisRequestConfig {}


/// Synthesizes speech and plays back the synthesized audio to the caller in
/// Telephony Gateway.
/// 
/// Telephony Gateway takes the synthesizer settings from
/// `DetectIntentResponse.output_audio_config` which can either be set
/// at request-level or can come from the agent-level synthesizer config.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageTelephonySynthesizeSpeech {
    /// The raw text to be synthesized.
    pub text: Option<String>,
    /// The SSML to be synthesized. For more information, see
    /// [SSML](https://developers.google.com/actions/reference/ssml).
    pub ssml: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageTelephonySynthesizeSpeech {}


/// Represents the natural language text to be processed.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1TextInput {
    /// Required. The language of this conversational query. See [Language
    /// Support](https://dialogflow.com/docs/languages) for a list of the
    /// currently supported language codes. Note that queries in the same session
    /// do not necessarily need to specify the same language.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// Required. The UTF-8 encoded natural language text to be processed.
    /// Text length must not exceed 256 bytes.
    pub text: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1TextInput {}


/// Represents an entity type.
/// Entity types serve as a tool for extracting parameter values from natural
/// language queries.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent entity types get projects](struct.ProjectAgentEntityTypeGetCall.html) (response)
/// * [agent entity types patch projects](struct.ProjectAgentEntityTypePatchCall.html) (request|response)
/// * [agent entity types create projects](struct.ProjectAgentEntityTypeCreateCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1EntityType {
    /// Optional. Indicates whether the entity type can be automatically
    /// expanded.
    #[serde(rename="autoExpansionMode")]
    pub auto_expansion_mode: Option<String>,
    /// Optional. The collection of entities associated with the entity type.
    pub entities: Option<Vec<GoogleCloudDialogflowV2beta1EntityTypeEntity>>,
    /// Required. Indicates the kind of entity type.
    pub kind: Option<String>,
    /// Required. The name of the entity type.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
    /// Required for all methods except `create` (`create` populates the name
    /// automatically.
    /// The unique identifier of the entity type. Format:
    /// `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    pub name: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1EntityType {}
impl ResponseResult for GoogleCloudDialogflowV2beta1EntityType {}


/// Transfers the call in Telephony Gateway.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageTelephonyTransferCall {
    /// Required. The phone number to transfer the call to
    /// in [E.164 format](https://en.wikipedia.org/wiki/E.164).
    /// 
    /// We currently only allow transferring to US numbers (+1xxxyyyzzzz).
    #[serde(rename="phoneNumber")]
    pub phone_number: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageTelephonyTransferCall {}


/// Optional. Represents an entity.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1EntityTypeEntity {
    /// Required. A collection of synonyms. For `KIND_LIST` entity types this
    /// must contain exactly one synonym equal to `value`.
    pub synonyms: Option<Vec<String>>,
    /// Required.
    /// For `KIND_MAP` entity types:
    ///   A canonical name to be used in place of synonyms.
    /// For `KIND_LIST` entity types:
    ///   A string that can contain references to other entity types (with or
    ///   without aliases).
    pub value: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1EntityTypeEntity {}


/// The basic card message. Useful for displaying information.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageBasicCard {
    /// Optional. The collection of card buttons.
    pub buttons: Option<Vec<GoogleCloudDialogflowV2beta1IntentMessageBasicCardButton>>,
    /// Required, unless image is present. The body text of the card.
    #[serde(rename="formattedText")]
    pub formatted_text: Option<String>,
    /// Optional. The image for the card.
    pub image: Option<GoogleCloudDialogflowV2beta1IntentMessageImage>,
    /// Optional. The subtitle of the card.
    pub subtitle: Option<String>,
    /// Optional. The title of the card.
    pub title: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageBasicCard {}


/// The card for presenting a list of options to select from.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageListSelect {
    /// Required. List items.
    pub items: Option<Vec<GoogleCloudDialogflowV2beta1IntentMessageListSelectItem>>,
    /// Optional. The overall title of the list.
    pub title: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageListSelect {}


/// The request message for Intents.BatchUpdateIntents.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent intents batch update projects](struct.ProjectAgentIntentBatchUpdateCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1BatchUpdateIntentsRequest {
    /// Optional. The language of training phrases, parameters and rich messages
    /// defined in `intents`. If not specified, the agent's default language is
    /// used. [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// The URI to a Google Cloud Storage file containing intents to update or
    /// create. The file format can either be a serialized proto (of IntentBatch
    /// type) or JSON object. Note: The URI must start with "gs://".
    #[serde(rename="intentBatchUri")]
    pub intent_batch_uri: Option<String>,
    /// The collection of intents to update or create.
    #[serde(rename="intentBatchInline")]
    pub intent_batch_inline: Option<GoogleCloudDialogflowV2beta1IntentBatch>,
    /// Optional. The mask to control which fields get updated.
    #[serde(rename="updateMask")]
    pub update_mask: Option<String>,
    /// Optional. The resource view to apply to the returned intent.
    #[serde(rename="intentView")]
    pub intent_view: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1BatchUpdateIntentsRequest {}


/// The request message for EntityTypes.BatchUpdateEntities.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent entity types entities batch update projects](struct.ProjectAgentEntityTypeEntityBatchUpdateCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1BatchUpdateEntitiesRequest {
    /// Optional. The language of entity synonyms defined in `entities`. If not
    /// specified, the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// Optional. The mask to control which fields get updated.
    #[serde(rename="updateMask")]
    pub update_mask: Option<String>,
    /// Required. The entities to update or create.
    pub entities: Option<Vec<GoogleCloudDialogflowV2beta1EntityTypeEntity>>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1BatchUpdateEntitiesRequest {}


/// Request for new numbers fitting a set of parameters.
/// The country code for newly requested numbers defaults to 1 (US) until the
/// service is available in other regions.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1PhoneNumberSpec {
    /// Optional. Area codes to use. An empty list means 'any code'. Each value
    /// is treated as equally preferred. Each entry has a limit of 10 bytes.
    /// "area code" corresponds to "National Destination Code" described in
    /// [E.164](https://en.wikipedia.org/wiki/E.164) standard.
    #[serde(rename="preferredAreaCodes")]
    pub preferred_area_codes: Option<Vec<String>>,
    /// Required. Total numbers requested, between 1 and 10 inclusive.
    pub count: Option<i32>,
}

impl Part for GoogleCloudDialogflowV2beta1PhoneNumberSpec {}


/// The response message for PhoneNumberOrders.ListPhoneNumberOrders.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [phone number orders list projects](struct.ProjectPhoneNumberOrderListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListPhoneNumberOrdersResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of orders. There is a maximum number of items returned based
    /// on the page_size field in the request.
    #[serde(rename="phoneNumberOrders")]
    pub phone_number_orders: Option<Vec<GoogleCloudDialogflowV2beta1PhoneNumberOrder>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListPhoneNumberOrdersResponse {}


/// The response message for Agents.SearchAgents.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent search projects](struct.ProjectAgentSearchCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1SearchAgentsResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of agents. There will be a maximum number of items returned based
    /// on the page_size field in the request.
    pub agents: Option<Vec<GoogleCloudDialogflowV2beta1Agent>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1SearchAgentsResponse {}


/// The sentiment, such as positive/negative feeling or association, for a unit
/// of analysis, such as the query text.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1Sentiment {
    /// Sentiment score between -1.0 (negative sentiment) and 1.0 (positive
    /// sentiment).
    pub score: Option<f32>,
    /// A non-negative number in the [0, +inf) range, which represents the absolute
    /// magnitude of sentiment, regardless of score (positive or negative).
    pub magnitude: Option<f32>,
}

impl Part for GoogleCloudDialogflowV2beta1Sentiment {}


/// The collection of simple response candidates.
/// This message in `QueryResult.fulfillment_messages` and
/// `WebhookResponse.fulfillment_messages` should contain only one
/// `SimpleResponse`.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageSimpleResponses {
    /// Required. The list of simple responses.
    #[serde(rename="simpleResponses")]
    pub simple_responses: Option<Vec<GoogleCloudDialogflowV2beta1IntentMessageSimpleResponse>>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageSimpleResponses {}


/// Optional. Contains information about a button.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageCardButton {
    /// Optional. The text to show on the button.
    pub text: Option<String>,
    /// Optional. The text to send back to the Dialogflow API or a URI to
    /// open.
    pub postback: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageCardButton {}


/// The response message for Intents.ListIntents.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent intents list projects](struct.ProjectAgentIntentListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListIntentsResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of agent intents. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub intents: Option<Vec<GoogleCloudDialogflowV2beta1Intent>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListIntentsResponse {}


/// The simple response message containing speech or text.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageSimpleResponse {
    /// One of text_to_speech or ssml must be provided. Structured spoken
    /// response to the user in the SSML format. Mutually exclusive with
    /// text_to_speech.
    pub ssml: Option<String>,
    /// One of text_to_speech or ssml must be provided. The plain text of the
    /// speech output. Mutually exclusive with ssml.
    #[serde(rename="textToSpeech")]
    pub text_to_speech: Option<String>,
    /// Optional. The text to display.
    #[serde(rename="displayText")]
    pub display_text: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageSimpleResponse {}


/// An item in the list.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageListSelectItem {
    /// Required. Additional information about this option.
    pub info: Option<GoogleCloudDialogflowV2beta1IntentMessageSelectItemInfo>,
    /// Optional. The image to display.
    pub image: Option<GoogleCloudDialogflowV2beta1IntentMessageImage>,
    /// Optional. The main text describing the item.
    pub description: Option<String>,
    /// Required. The title of the list item.
    pub title: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageListSelectItem {}


/// Response message for KnowledgeBases.ListKnowledgeBases.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent knowledge bases list projects](struct.ProjectAgentKnowledgeBaseListCall.html) (response)
/// * [knowledge bases list projects](struct.ProjectKnowledgeBaseListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListKnowledgeBasesResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of knowledge bases.
    #[serde(rename="knowledgeBases")]
    pub knowledge_bases: Option<Vec<GoogleCloudDialogflowV2beta1KnowledgeBase>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListKnowledgeBasesResponse {}


/// The request message for Intents.BatchDeleteIntents.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent intents batch delete projects](struct.ProjectAgentIntentBatchDeleteCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1BatchDeleteIntentsRequest {
    /// Required. The collection of intents to delete. Only intent `name` must be
    /// filled in.
    pub intents: Option<Vec<GoogleCloudDialogflowV2beta1Intent>>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1BatchDeleteIntentsRequest {}


/// The request message for PhoneNumberOrders.CancelPhoneNumberOrder.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [phone number orders cancel projects](struct.ProjectPhoneNumberOrderCancelCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1CancelPhoneNumberOrderRequest { _never_set: Option<bool> }

impl RequestValue for GoogleCloudDialogflowV2beta1CancelPhoneNumberOrderRequest {}


/// The response message for SessionEntityTypes.ListSessionEntityTypes.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent environments users sessions entity types list projects](struct.ProjectAgentEnvironmentUserSessionEntityTypeListCall.html) (response)
/// * [agent sessions entity types list projects](struct.ProjectAgentSessionEntityTypeListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListSessionEntityTypesResponse {
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
    /// The list of session entity types. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    #[serde(rename="sessionEntityTypes")]
    pub session_entity_types: Option<Vec<GoogleCloudDialogflowV2beta1SessionEntityType>>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListSessionEntityTypesResponse {}


/// The request message for Conversations.CompleteConversation.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations complete projects](struct.ProjectConversationCompleteCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1CompleteConversationRequest { _never_set: Option<bool> }

impl RequestValue for GoogleCloudDialogflowV2beta1CompleteConversationRequest {}


/// Represents suggested answer from "frequently asked questions".
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1SuggestionFaqAnswer {
    /// Output only. The piece of text from the `source` knowledge base document.
    pub answer: Option<String>,
    /// Output only. Indicates which Knowledge Document this answer was extracted
    /// from.
    /// Format: `projects/<Project ID>/agent/knowledgeBases/<Knowledge Base
    /// ID>/documents/<Document ID>`.
    pub source: Option<String>,
    /// The system's confidence score that this Knowledge answer is a good match
    /// for this conversational query, range from 0.0 (completely uncertain)
    /// to 1.0 (completely certain).
    pub confidence: Option<f32>,
    /// Output only. The corresponding FAQ question.
    pub question: Option<String>,
    /// Output only. A map that contains metadata about the answer and the
    /// document from which it originates.
    pub metadata: Option<HashMap<String, String>>,
}

impl Part for GoogleCloudDialogflowV2beta1SuggestionFaqAnswer {}


/// The suggestion chip message that the user can tap to quickly post a reply
/// to the conversation.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageSuggestion {
    /// Required. The text shown the in the suggestion chip.
    pub title: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageSuggestion {}


/// Instructs the speech recognizer how to process the audio content.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1InputAudioConfig {
    /// Optional. The collection of phrase hints which are used to boost accuracy
    /// of speech recognition.
    /// Refer to
    /// [Cloud Speech API
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints)
    /// for more details.
    #[serde(rename="phraseHints")]
    pub phrase_hints: Option<Vec<String>>,
    /// Required. The language of the supplied audio. Dialogflow does not do
    /// translations. See [Language
    /// Support](https://dialogflow.com/docs/languages) for a list of the
    /// currently supported language codes. Note that queries in the same session
    /// do not necessarily need to specify the same language.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// Optional. Which Speech model to select for the given request. Select the
    /// model best suited to your domain to get best results. If a model is not
    /// explicitly specified, then we auto-select a model based on the parameters
    /// in the InputAudioConfig.
    /// If enhanced speech model is enabled for the agent and an enhanced
    /// version of the specified model for the language does not exist, then the
    /// speech is recognized using the standard version of the specified model.
    /// Refer to
    /// [Cloud Speech API
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model)
    /// for more details.
    pub model: Option<String>,
    /// Required. Sample rate (in Hertz) of the audio content sent in the query.
    /// Refer to
    /// [Cloud Speech API
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics) for
    /// more details.
    #[serde(rename="sampleRateHertz")]
    pub sample_rate_hertz: Option<i32>,
    /// Required. Audio encoding of the audio content to process.
    #[serde(rename="audioEncoding")]
    pub audio_encoding: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1InputAudioConfig {}


/// The suggestion chip message that allows the user to jump out to the app
/// or website associated with this agent.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageLinkOutSuggestion {
    /// Required. The URI of the app or site to open when the user taps the
    /// suggestion chip.
    pub uri: Option<String>,
    /// Required. The name of the app or site this chip is linking to.
    #[serde(rename="destinationName")]
    pub destination_name: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageLinkOutSuggestion {}


/// Represents the natural language speech audio to be played to the end user.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1OutputAudio {
    /// Required. The natural language speech audio.
    pub audio: Option<String>,
    /// Required. Instructs the speech synthesizer how to generate the speech
    /// audio.
    pub config: Option<GoogleCloudDialogflowV2beta1OutputAudioConfig>,
}

impl Part for GoogleCloudDialogflowV2beta1OutputAudio {}


/// The response message for Contexts.ListContexts.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [environments users conversations contexts list projects](struct.ProjectEnvironmentUserConversationContextListCall.html) (response)
/// * [agent environments users sessions contexts list projects](struct.ProjectAgentEnvironmentUserSessionContextListCall.html) (response)
/// * [agent sessions contexts list projects](struct.ProjectAgentSessionContextListCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ListContextsResponse {
    /// The list of contexts. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub contexts: Option<Vec<GoogleCloudDialogflowV2beta1Context>>,
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[serde(rename="nextPageToken")]
    pub next_page_token: Option<String>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1ListContextsResponse {}


/// Defines the language used in the input text.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1InputTextConfig {
    /// Required. The language of this conversational query. See [Language
    /// Support](https://dialogflow.com/docs/languages) for a list of the
    /// currently supported language codes.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1InputTextConfig {}


/// Represents the natural language speech audio to be processed.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1InputAudio {
    /// Required. The natural language speech audio to be processed.
    /// A single request can contain up to 1 minute of speech audio data.
    /// The transcribed text cannot contain more than 256 bytes.
    pub audio: Option<String>,
    /// Required. Instructs the speech recognizer how to process the speech audio.
    pub config: Option<GoogleCloudDialogflowV2beta1InputAudioConfig>,
}

impl Part for GoogleCloudDialogflowV2beta1InputAudio {}


/// A generic empty message that you can re-use to avoid defining duplicated
/// empty messages in your APIs. A typical example is to use it as the request
/// or the response type of an API method. For instance:
/// 
///     service Foo {
///       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
///     }
/// 
/// The JSON representation for `Empty` is empty JSON object `{}`.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [phone number orders cancel projects](struct.ProjectPhoneNumberOrderCancelCall.html) (response)
/// * [agent environments users sessions contexts delete projects](struct.ProjectAgentEnvironmentUserSessionContextDeleteCall.html) (response)
/// * [human agent assistants delete projects](struct.ProjectHumanAgentAssistantDeleteCall.html) (response)
/// * [agent environments users sessions entity types delete projects](struct.ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall.html) (response)
/// * [agent sessions delete contexts projects](struct.ProjectAgentSessionDeleteContextCall.html) (response)
/// * [agent knowledge bases delete projects](struct.ProjectAgentKnowledgeBaseDeleteCall.html) (response)
/// * [knowledge bases delete projects](struct.ProjectKnowledgeBaseDeleteCall.html) (response)
/// * [agent entity types delete projects](struct.ProjectAgentEntityTypeDeleteCall.html) (response)
/// * [agent sessions contexts delete projects](struct.ProjectAgentSessionContextDeleteCall.html) (response)
/// * [environments users conversations contexts delete projects](struct.ProjectEnvironmentUserConversationContextDeleteCall.html) (response)
/// * [agent sessions entity types delete projects](struct.ProjectAgentSessionEntityTypeDeleteCall.html) (response)
/// * [agent environments users sessions delete contexts projects](struct.ProjectAgentEnvironmentUserSessionDeleteContextCall.html) (response)
/// * [environments users conversations delete contexts projects](struct.ProjectEnvironmentUserConversationDeleteContextCall.html) (response)
/// * [agent intents delete projects](struct.ProjectAgentIntentDeleteCall.html) (response)
/// * [conversation profiles delete projects](struct.ProjectConversationProfileDeleteCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleProtobufEmpty { _never_set: Option<bool> }

impl ResponseResult for GoogleProtobufEmpty {}


/// Represents a part of a training phrase.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentTrainingPhrasePart {
    /// Optional. The parameter name for the value extracted from the
    /// annotated part of the example.
    pub alias: Option<String>,
    /// Optional. The entity type name prefixed with `@`. This field is
    /// required for the annotated part of the text and applies only to
    /// examples.
    #[serde(rename="entityType")]
    pub entity_type: Option<String>,
    /// Optional. Indicates whether the text was manually annotated by the
    /// developer.
    #[serde(rename="userDefined")]
    pub user_defined: Option<bool>,
    /// Required. The text corresponding to the example or template,
    /// if there are no annotations. For
    /// annotated examples, it is the text for one of the example's parts.
    pub text: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentTrainingPhrasePart {}


/// Defines the services to connect to incoming Dialogflow conversations.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversation profiles create projects](struct.ProjectConversationProfileCreateCall.html) (request|response)
/// * [conversation profiles get projects](struct.ProjectConversationProfileGetCall.html) (response)
/// * [conversation profiles patch projects](struct.ProjectConversationProfilePatchCall.html) (request|response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1ConversationProfile {
    /// Optional. Configuration for agent assistance to use with this profile.
    #[serde(rename="humanAgentAssistantConfig")]
    pub human_agent_assistant_config: Option<GoogleCloudDialogflowV2beta1HumanAgentAssistantConfig>,
    /// Optional. Configuration for logging conversation lifecycle events.
    #[serde(rename="loggingConfig")]
    pub logging_config: Option<GoogleCloudDialogflowV2beta1LoggingConfig>,
    /// Required for all methods except `create` (`create` populates the name
    /// automatically).
    /// The unique identifier of this conversation profile.
    /// Format: `projects/<Project ID>/conversationProfiles/<Conversation Profile
    /// ID>`.
    pub name: Option<String>,
    /// Required. Human readable name for this profile. Max length 1024 bytes.
    #[serde(rename="displayName")]
    pub display_name: Option<String>,
    /// Optional. Configuration for an automated agent to use with this profile.
    #[serde(rename="automatedAgentConfig")]
    pub automated_agent_config: Option<GoogleCloudDialogflowV2beta1AutomatedAgentConfig>,
    /// Optional. Configuration for publishing conversation lifecycle events.
    #[serde(rename="notificationConfig")]
    pub notification_config: Option<GoogleCloudDialogflowV2beta1NotificationConfig>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1ConversationProfile {}
impl ResponseResult for GoogleCloudDialogflowV2beta1ConversationProfile {}


/// Represents the result of conversational query or event processing.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1QueryResult {
    /// The language that was triggered during intent detection.
    /// See [Language Support](https://dialogflow.com/docs/reference/language)
    /// for a list of the currently supported language codes.
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// The text to be pronounced to the user or shown on the screen.
    #[serde(rename="fulfillmentText")]
    pub fulfillment_text: Option<String>,
    /// This field is set to:
    /// - `false` if the matched intent has required parameters and not all of
    ///    the required parameter values have been collected.
    /// - `true` if all required parameter values have been collected, or if the
    ///    matched intent doesn't contain any required parameters.
    #[serde(rename="allRequiredParamsPresent")]
    pub all_required_params_present: Option<bool>,
    /// The collection of rich messages to present to the user.
    #[serde(rename="fulfillmentMessages")]
    pub fulfillment_messages: Option<Vec<GoogleCloudDialogflowV2beta1IntentMessage>>,
    /// The action name from the matched intent.
    pub action: Option<String>,
    /// The intent that matched the conversational query. Some, not
    /// all fields are filled in this message, including but not limited to:
    /// `name`, `display_name` and `webhook_state`.
    pub intent: Option<GoogleCloudDialogflowV2beta1Intent>,
    /// The free-form diagnostic info. For example, this field
    /// could contain webhook call latency.
    #[serde(rename="diagnosticInfo")]
    pub diagnostic_info: Option<HashMap<String, String>>,
    /// The collection of output contexts. If applicable,
    /// `output_contexts.parameters` contains entries with name
    /// `<parameter name>.original` containing the original parameter values
    /// before the query.
    #[serde(rename="outputContexts")]
    pub output_contexts: Option<Vec<GoogleCloudDialogflowV2beta1Context>>,
    /// The result from Knowledge Connector (if any), ordered by decreasing
    /// `KnowledgeAnswers.match_confidence`.
    #[serde(rename="knowledgeAnswers")]
    pub knowledge_answers: Option<GoogleCloudDialogflowV2beta1KnowledgeAnswers>,
    /// The sentiment analysis result, which depends on the
    /// `sentiment_analysis_request_config` specified in the request.
    #[serde(rename="sentimentAnalysisResult")]
    pub sentiment_analysis_result: Option<GoogleCloudDialogflowV2beta1SentimentAnalysisResult>,
    /// If the query was fulfilled by a webhook call, this field is set to the
    /// value of the `payload` field returned in the webhook response.
    #[serde(rename="webhookPayload")]
    pub webhook_payload: Option<HashMap<String, String>>,
    /// The collection of extracted parameters.
    pub parameters: Option<HashMap<String, String>>,
    /// The Speech recognition confidence between 0.0 and 1.0. A higher number
    /// indicates an estimated greater likelihood that the recognized words are
    /// correct. The default of 0.0 is a sentinel value indicating that confidence
    /// was not set.
    /// 
    /// This field is not guaranteed to be accurate or set. In particular this
    /// field isn't set for StreamingDetectIntent since the streaming endpoint has
    /// separate confidence estimates per portion of the audio in
    /// StreamingRecognitionResult.
    #[serde(rename="speechRecognitionConfidence")]
    pub speech_recognition_confidence: Option<f32>,
    /// The intent detection confidence. Values range from 0.0
    /// (completely uncertain) to 1.0 (completely certain).
    /// If there are `multiple knowledge_answers` messages, this value is set to
    /// the greatest `knowledgeAnswers.match_confidence` value in the list.
    #[serde(rename="intentDetectionConfidence")]
    pub intent_detection_confidence: Option<f32>,
    /// The original conversational query text:
    /// - If natural language text was provided as input, `query_text` contains
    ///   a copy of the input.
    /// - If natural language speech audio was provided as input, `query_text`
    ///   contains the speech recognition result. If speech recognizer produced
    ///   multiple alternatives, a particular one is picked.
    /// - If an event was provided as input, `query_text` is not set.
    #[serde(rename="queryText")]
    pub query_text: Option<String>,
    /// If the query was fulfilled by a webhook call, this field is set to the
    /// value of the `source` field returned in the webhook response.
    #[serde(rename="webhookSource")]
    pub webhook_source: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1QueryResult {}


/// The message returned from the DetectIntent method.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent environments users sessions detect intent projects](struct.ProjectAgentEnvironmentUserSessionDetectIntentCall.html) (response)
/// * [agent sessions detect intent projects](struct.ProjectAgentSessionDetectIntentCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1DetectIntentResponse {
    /// Instructs the speech synthesizer how to generate the output audio. This
    /// field is populated from the agent-level speech synthesizer configuration,
    /// if enabled.
    #[serde(rename="outputAudioConfig")]
    pub output_audio_config: Option<GoogleCloudDialogflowV2beta1OutputAudioConfig>,
    /// The audio data bytes encoded as specified in the request.
    #[serde(rename="outputAudio")]
    pub output_audio: Option<String>,
    /// The selected results of the conversational query or event processing.
    /// See `alternative_query_results` for additional potential results.
    #[serde(rename="queryResult")]
    pub query_result: Option<GoogleCloudDialogflowV2beta1QueryResult>,
    /// If Knowledge Connectors are enabled, there could be more than one result
    /// returned for a given query or event, and this field will contain all
    /// results except for the top one, which is captured in query_result. The
    /// alternative results are ordered by decreasing
    /// `QueryResult.intent_detection_confidence`. If Knowledge Connectors are
    /// disabled, this field will be empty until multiple responses for regular
    /// intents are supported, at which point those additional results will be
    /// surfaced here.
    #[serde(rename="alternativeQueryResults")]
    pub alternative_query_results: Option<Vec<GoogleCloudDialogflowV2beta1QueryResult>>,
    /// Specifies the status of the webhook request. `webhook_status`
    /// is never populated in webhook requests.
    #[serde(rename="webhookStatus")]
    pub webhook_status: Option<GoogleRpcStatus>,
    /// The unique identifier of the response. It can be used to
    /// locate a response in the training example set or for reporting issues.
    #[serde(rename="responseId")]
    pub response_id: Option<String>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1DetectIntentResponse {}


/// The `Status` type defines a logical error model that is suitable for different
/// programming environments, including REST APIs and RPC APIs. It is used by
/// [gRPC](https://github.com/grpc). The error model is designed to be:
/// 
/// - Simple to use and understand for most users
/// - Flexible enough to meet unexpected needs
/// 
/// # Overview
/// 
/// The `Status` message contains three pieces of data: error code, error message,
/// and error details. The error code should be an enum value of
/// google.rpc.Code, but it may accept additional error codes if needed.  The
/// error message should be a developer-facing English message that helps
/// developers *understand* and *resolve* the error. If a localized user-facing
/// error message is needed, put the localized message in the error details or
/// localize it in the client. The optional error details may contain arbitrary
/// information about the error. There is a predefined set of error detail types
/// in the package `google.rpc` that can be used for common error conditions.
/// 
/// # Language mapping
/// 
/// The `Status` message is the logical representation of the error model, but it
/// is not necessarily the actual wire format. When the `Status` message is
/// exposed in different client libraries and different wire protocols, it can be
/// mapped differently. For example, it will likely be mapped to some exceptions
/// in Java, but more likely mapped to some error codes in C.
/// 
/// # Other uses
/// 
/// The error model and the `Status` message can be used in a variety of
/// environments, either with or without APIs, to provide a
/// consistent developer experience across different environments.
/// 
/// Example uses of this error model include:
/// 
/// - Partial errors. If a service needs to return partial errors to the client,
///     it may embed the `Status` in the normal response to indicate the partial
///     errors.
/// 
/// - Workflow errors. A typical workflow has multiple steps. Each step may
///     have a `Status` message for error reporting.
/// 
/// - Batch operations. If a client uses batch request and batch response, the
///     `Status` message should be used directly inside batch response, one for
///     each error sub-response.
/// 
/// - Asynchronous operations. If an API call embeds asynchronous operation
///     results in its response, the status of those operations should be
///     represented directly using the `Status` message.
/// 
/// - Logging. If some API errors are stored in logs, the message `Status` could
///     be used directly after any stripping needed for security/privacy reasons.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleRpcStatus {
    /// A developer-facing error message, which should be in English. Any
    /// user-facing error message should be localized and sent in the
    /// google.rpc.Status.details field, or localized by the client.
    pub message: Option<String>,
    /// The status code, which should be an enum value of google.rpc.Code.
    pub code: Option<i32>,
    /// A list of messages that carry the error details.  There is a common set of
    /// message types for APIs to use.
    pub details: Option<Vec<HashMap<String, String>>>,
}

impl Part for GoogleRpcStatus {}


/// Description of which voice to use for speech synthesis.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1VoiceSelectionParams {
    /// Optional. The preferred gender of the voice. If not set, the service will
    /// choose a voice based on the other parameters such as language_code and
    /// name. Note that this is only a preference, not requirement. If a
    /// voice of the appropriate gender is not available, the synthesizer should
    /// substitute a voice with a different gender rather than failing the request.
    #[serde(rename="ssmlGender")]
    pub ssml_gender: Option<String>,
    /// Optional. The name of the voice. If not set, the service will choose a
    /// voice based on the other parameters such as language_code and gender.
    pub name: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1VoiceSelectionParams {}


/// The response message for Conversations.AnalyzeContent.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [conversations participants analyze content projects](struct.ProjectConversationParticipantAnalyzeContentCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1AnalyzeContentResponse {
    /// Optional. Only set if a Dialogflow automated agent has responded.
    #[serde(rename="automatedAgentReply")]
    pub automated_agent_reply: Option<GoogleCloudDialogflowV2beta1AutomatedAgentReply>,
    /// Output only. The output text content.
    /// This field is set if the automated agent responded with text to show to
    /// the user.
    #[serde(rename="replyText")]
    pub reply_text: Option<String>,
    /// Optional. The audio data bytes encoded as specified in the request.
    /// This field is set if:
    ///  - `reply_audio_config` was specified in the request, or
    ///  - The automated agent responded with audio to play to the user. In such
    ///    case, `reply_audio.config` contains settings used to synthesize the
    ///    speech.
    #[serde(rename="replyAudio")]
    pub reply_audio: Option<GoogleCloudDialogflowV2beta1OutputAudio>,
}

impl ResponseResult for GoogleCloudDialogflowV2beta1AnalyzeContentResponse {}


/// Represents a phone number order.
/// Orders can assign phone numbers to projects.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [phone number orders create projects](struct.ProjectPhoneNumberOrderCreateCall.html) (request|response)
/// * [phone number orders patch projects](struct.ProjectPhoneNumberOrderPatchCall.html) (request|response)
/// * [phone number orders get projects](struct.ProjectPhoneNumberOrderGetCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1PhoneNumberOrder {
    /// Output only. The time this order was last updated.
    #[serde(rename="updateTime")]
    pub update_time: Option<String>,
    /// Required. The unique identifier of this order.
    /// Format: `projects/<Project ID>/phoneNumberOrders/<Order ID>`.
    pub name: Option<String>,
    /// Output only. A map of ordered numbers filled so far, keyed by their
    /// resource name. Key format:
    /// `projects/<Project ID>/phoneNumbers/<PhoneNumber ID>`.
    /// Value format: E.164 phone number. Output only.
    #[serde(rename="phoneNumbers")]
    pub phone_numbers: Option<HashMap<String, String>>,
    /// Optional. A description of the order, limit is 1024 bytes.
    pub description: Option<String>,
    /// Order is for new numbers.
    #[serde(rename="phoneNumberSpec")]
    pub phone_number_spec: Option<GoogleCloudDialogflowV2beta1PhoneNumberSpec>,
    /// Output only. The time this order was created.
    #[serde(rename="createTime")]
    pub create_time: Option<String>,
    /// Output only. The current status of the order.
    #[serde(rename="lifecycleState")]
    pub lifecycle_state: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1PhoneNumberOrder {}
impl ResponseResult for GoogleCloudDialogflowV2beta1PhoneNumberOrder {}


/// The button object that appears at the bottom of a card.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageBasicCardButton {
    /// Required. Action to take when a user taps on the button.
    #[serde(rename="openUriAction")]
    pub open_uri_action: Option<GoogleCloudDialogflowV2beta1IntentMessageBasicCardButtonOpenUriAction>,
    /// Required. The title of the button.
    pub title: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageBasicCardButton {}


/// The text response message.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageText {
    /// Optional. The collection of the agent's responses.
    pub text: Option<Vec<String>>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageText {}


/// Represents a context.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent sessions contexts get projects](struct.ProjectAgentSessionContextGetCall.html) (response)
/// * [agent environments users sessions contexts patch projects](struct.ProjectAgentEnvironmentUserSessionContextPatchCall.html) (request|response)
/// * [agent environments users sessions contexts create projects](struct.ProjectAgentEnvironmentUserSessionContextCreateCall.html) (request|response)
/// * [agent environments users sessions contexts get projects](struct.ProjectAgentEnvironmentUserSessionContextGetCall.html) (response)
/// * [agent sessions contexts patch projects](struct.ProjectAgentSessionContextPatchCall.html) (request|response)
/// * [environments users conversations contexts create projects](struct.ProjectEnvironmentUserConversationContextCreateCall.html) (request|response)
/// * [environments users conversations contexts patch projects](struct.ProjectEnvironmentUserConversationContextPatchCall.html) (request|response)
/// * [agent sessions contexts create projects](struct.ProjectAgentSessionContextCreateCall.html) (request|response)
/// * [environments users conversations contexts get projects](struct.ProjectEnvironmentUserConversationContextGetCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1Context {
    /// Required. The unique identifier of the context. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`,
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. The `Context ID` is
    /// always converted to lowercase. If `Environment ID` is not specified, we
    /// assume default 'draft' environment. If `User ID` is not specified, we
    /// assume default '-' user.
    pub name: Option<String>,
    /// Optional. The collection of parameters associated with this context.
    /// Refer to [this doc](https://dialogflow.com/docs/actions-and-parameters) for
    /// syntax.
    pub parameters: Option<HashMap<String, String>>,
    /// Optional. The number of conversational query requests after which the
    /// context expires. If set to `0` (the default) the context expires
    /// immediately. Contexts expire automatically after 10 minutes even if there
    /// are no matching queries.
    #[serde(rename="lifespanCount")]
    pub lifespan_count: Option<i32>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1Context {}
impl ResponseResult for GoogleCloudDialogflowV2beta1Context {}


/// This resource represents a long-running operation that is the result of a
/// network API call.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent restore projects](struct.ProjectAgentRestoreCall.html) (response)
/// * [agent intents batch delete projects](struct.ProjectAgentIntentBatchDeleteCall.html) (response)
/// * [knowledge bases documents create projects](struct.ProjectKnowledgeBaseDocumentCreateCall.html) (response)
/// * [knowledge bases documents delete projects](struct.ProjectKnowledgeBaseDocumentDeleteCall.html) (response)
/// * [agent entity types batch delete projects](struct.ProjectAgentEntityTypeBatchDeleteCall.html) (response)
/// * [agent train projects](struct.ProjectAgentTrainCall.html) (response)
/// * [agent knowledge bases documents delete projects](struct.ProjectAgentKnowledgeBaseDocumentDeleteCall.html) (response)
/// * [agent import projects](struct.ProjectAgentImportCall.html) (response)
/// * [agent entity types batch update projects](struct.ProjectAgentEntityTypeBatchUpdateCall.html) (response)
/// * [agent export projects](struct.ProjectAgentExportCall.html) (response)
/// * [agent knowledge bases documents create projects](struct.ProjectAgentKnowledgeBaseDocumentCreateCall.html) (response)
/// * [agent intents batch update projects](struct.ProjectAgentIntentBatchUpdateCall.html) (response)
/// * [agent entity types entities batch update projects](struct.ProjectAgentEntityTypeEntityBatchUpdateCall.html) (response)
/// * [agent entity types entities batch delete projects](struct.ProjectAgentEntityTypeEntityBatchDeleteCall.html) (response)
/// * [operations get projects](struct.ProjectOperationGetCall.html) (response)
/// * [agent entity types entities batch create projects](struct.ProjectAgentEntityTypeEntityBatchCreateCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleLongrunningOperation {
    /// The error result of the operation in case of failure or cancellation.
    pub error: Option<GoogleRpcStatus>,
    /// If the value is `false`, it means the operation is still in progress.
    /// If `true`, the operation is completed, and either `error` or `response` is
    /// available.
    pub done: Option<bool>,
    /// The normal response of the operation in case of success.  If the original
    /// method returns no data on success, such as `Delete`, the response is
    /// `google.protobuf.Empty`.  If the original method is standard
    /// `Get`/`Create`/`Update`, the response should be the resource.  For other
    /// methods, the response should have the type `XxxResponse`, where `Xxx`
    /// is the original method name.  For example, if the original method name
    /// is `TakeSnapshot()`, the inferred response type is
    /// `TakeSnapshotResponse`.
    pub response: Option<HashMap<String, String>>,
    /// The server-assigned name, which is only unique within the same service that
    /// originally returns it. If you use the default HTTP mapping, the
    /// `name` should have the format of `operations/some/unique/name`.
    pub name: Option<String>,
    /// Service-specific metadata associated with the operation.  It typically
    /// contains progress information and common metadata such as create time.
    /// Some services might not provide such metadata.  Any method that returns a
    /// long-running operation should document the metadata type, if any.
    pub metadata: Option<HashMap<String, String>>,
}

impl ResponseResult for GoogleLongrunningOperation {}


/// The request message for Agents.RestoreAgent.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [agent restore projects](struct.ProjectAgentRestoreCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1RestoreAgentRequest {
    /// The URI to a Google Cloud Storage file containing the agent to restore.
    /// Note: The URI must start with "gs://".
    #[serde(rename="agentUri")]
    pub agent_uri: Option<String>,
    /// The agent to restore.
    /// 
    /// Example for how to restore an agent via the command line:
    /// <pre>curl \
    ///   'https://dialogflow.googleapis.com/v2beta1/projects/&lt;project_name&gt;/agent:restore\
    ///    -X POST \
    ///    -H 'Authorization: Bearer '$(gcloud auth application-default
    ///    print-access-token) \
    ///    -H 'Accept: application/json' \
    ///    -H 'Content-Type: application/json' \
    ///    --compressed \
    ///    --data-binary "{
    ///        'agentContent': '$(cat &lt;agent zip file&gt; | base64 -w 0)'
    ///    }"</pre>
    #[serde(rename="agentContent")]
    pub agent_content: Option<String>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1RestoreAgentRequest {}


/// The quick replies response message.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1IntentMessageQuickReplies {
    /// Optional. The collection of quick replies.
    #[serde(rename="quickReplies")]
    pub quick_replies: Option<Vec<String>>,
    /// Optional. The title of the collection of quick replies.
    pub title: Option<String>,
}

impl Part for GoogleCloudDialogflowV2beta1IntentMessageQuickReplies {}


/// The request message for
/// HumanAgentAssistants.RequestCompileSuggestions.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [human agent assistants compile suggestions projects](struct.ProjectHumanAgentAssistantCompileSuggestionCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1CompileSuggestionsRequest {
    /// Required. List of messages in a conversation in chronological order.
    pub messages: Option<Vec<GoogleCloudDialogflowV2beta1Message>>,
}

impl RequestValue for GoogleCloudDialogflowV2beta1CompileSuggestionsRequest {}


/// Represents suggested article.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GoogleCloudDialogflowV2beta1SuggestionArticle {
    /// Output only. The article title.
    pub title: Option<String>,
    /// Output only. The article URI.
    pub uri: Option<String>,
    /// Output only. Article snippets.
    pub snippets: Option<Vec<String>>,
    /// Output only. A map that contains metadata about the answer and the
    /// document from which it originates.
    pub metadata: Option<HashMap<String, String>>,
}

impl Part for GoogleCloudDialogflowV2beta1SuggestionArticle {}



// ###################
// MethodBuilders ###
// #################

/// A builder providing access to all methods supported on *project* resources.
/// It is not used directly, but through the `Dialogflow` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate hyper_rustls;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use dialogflow2_beta1::Dialogflow;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `agent_entity_types_batch_delete(...)`, `agent_entity_types_batch_update(...)`, `agent_entity_types_create(...)`, `agent_entity_types_delete(...)`, `agent_entity_types_entities_batch_create(...)`, `agent_entity_types_entities_batch_delete(...)`, `agent_entity_types_entities_batch_update(...)`, `agent_entity_types_get(...)`, `agent_entity_types_list(...)`, `agent_entity_types_patch(...)`, `agent_environments_users_sessions_contexts_create(...)`, `agent_environments_users_sessions_contexts_delete(...)`, `agent_environments_users_sessions_contexts_get(...)`, `agent_environments_users_sessions_contexts_list(...)`, `agent_environments_users_sessions_contexts_patch(...)`, `agent_environments_users_sessions_delete_contexts(...)`, `agent_environments_users_sessions_detect_intent(...)`, `agent_environments_users_sessions_entity_types_create(...)`, `agent_environments_users_sessions_entity_types_delete(...)`, `agent_environments_users_sessions_entity_types_get(...)`, `agent_environments_users_sessions_entity_types_list(...)`, `agent_environments_users_sessions_entity_types_patch(...)`, `agent_export(...)`, `agent_import(...)`, `agent_intents_batch_delete(...)`, `agent_intents_batch_update(...)`, `agent_intents_create(...)`, `agent_intents_delete(...)`, `agent_intents_get(...)`, `agent_intents_list(...)`, `agent_intents_patch(...)`, `agent_knowledge_bases_create(...)`, `agent_knowledge_bases_delete(...)`, `agent_knowledge_bases_documents_create(...)`, `agent_knowledge_bases_documents_delete(...)`, `agent_knowledge_bases_documents_get(...)`, `agent_knowledge_bases_documents_list(...)`, `agent_knowledge_bases_get(...)`, `agent_knowledge_bases_list(...)`, `agent_restore(...)`, `agent_search(...)`, `agent_sessions_contexts_create(...)`, `agent_sessions_contexts_delete(...)`, `agent_sessions_contexts_get(...)`, `agent_sessions_contexts_list(...)`, `agent_sessions_contexts_patch(...)`, `agent_sessions_delete_contexts(...)`, `agent_sessions_detect_intent(...)`, `agent_sessions_entity_types_create(...)`, `agent_sessions_entity_types_delete(...)`, `agent_sessions_entity_types_get(...)`, `agent_sessions_entity_types_list(...)`, `agent_sessions_entity_types_patch(...)`, `agent_train(...)`, `conversation_profiles_create(...)`, `conversation_profiles_delete(...)`, `conversation_profiles_get(...)`, `conversation_profiles_list(...)`, `conversation_profiles_patch(...)`, `conversations_add_conversation_phone_number(...)`, `conversations_complete(...)`, `conversations_create(...)`, `conversations_get(...)`, `conversations_list(...)`, `conversations_messages_list(...)`, `conversations_participants_analyze_content(...)`, `conversations_participants_create(...)`, `conversations_participants_get(...)`, `conversations_participants_list(...)`, `conversations_participants_streaming_analyze_content(...)`, `conversations_participants_suggestions_list(...)`, `environments_users_conversations_contexts_create(...)`, `environments_users_conversations_contexts_delete(...)`, `environments_users_conversations_contexts_get(...)`, `environments_users_conversations_contexts_list(...)`, `environments_users_conversations_contexts_patch(...)`, `environments_users_conversations_delete_contexts(...)`, `get_agent(...)`, `human_agent_assistants_compile_suggestions(...)`, `human_agent_assistants_create(...)`, `human_agent_assistants_delete(...)`, `human_agent_assistants_get(...)`, `human_agent_assistants_list(...)`, `human_agent_assistants_patch(...)`, `knowledge_bases_create(...)`, `knowledge_bases_delete(...)`, `knowledge_bases_documents_create(...)`, `knowledge_bases_documents_delete(...)`, `knowledge_bases_documents_get(...)`, `knowledge_bases_documents_list(...)`, `knowledge_bases_get(...)`, `knowledge_bases_list(...)`, `operations_get(...)`, `phone_number_orders_cancel(...)`, `phone_number_orders_create(...)`, `phone_number_orders_get(...)`, `phone_number_orders_list(...)`, `phone_number_orders_patch(...)`, `phone_numbers_delete(...)`, `phone_numbers_list(...)`, `phone_numbers_patch(...)` and `phone_numbers_undelete(...)`
/// // to build up your call.
/// let rb = hub.projects();
/// # }
/// ```
pub struct ProjectMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
}

impl<'a, C, A> MethodsBuilder for ProjectMethods<'a, C, A> {}

impl<'a, C, A> ProjectMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified session entity type.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the session entity type. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    ///            Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    ///            ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    ///            Name>`. If `Environment ID` is not specified, we assume default 'draft'
    ///            environment. If `User ID` is not specified, we assume default '-' user.
    pub fn agent_environments_users_sessions_entity_types_get(&self, name: &str) -> ProjectAgentEnvironmentUserSessionEntityTypeGetCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionEntityTypeGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified context.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the context. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    ///            or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    ///            not specified, we assume default 'draft' environment. If `User ID` is not
    ///            specified, we assume default '-' user.
    pub fn agent_environments_users_sessions_contexts_get(&self, name: &str) -> ProjectAgentEnvironmentUserSessionContextGetCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionContextGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates/Creates multiple entity types in the specified agent.
    /// 
    /// Operation <response: BatchUpdateEntityTypesResponse,
    ///            metadata: google.protobuf.Struct>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The name of the agent to update or create entity types in.
    ///              Format: `projects/<Project ID>/agent`.
    pub fn agent_entity_types_batch_update(&self, request: GoogleCloudDialogflowV2beta1BatchUpdateEntityTypesRequest, parent: &str) -> ProjectAgentEntityTypeBatchUpdateCall<'a, C, A> {
        ProjectAgentEntityTypeBatchUpdateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a knowledge base.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The project to create a knowledge base for.
    ///              Format: `projects/<Project ID>`.
    pub fn agent_knowledge_bases_create(&self, request: GoogleCloudDialogflowV2beta1KnowledgeBase, parent: &str) -> ProjectAgentKnowledgeBaseCreateCall<'a, C, A> {
        ProjectAgentKnowledgeBaseCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates/Creates multiple intents in the specified agent.
    /// 
    /// Operation <response: BatchUpdateIntentsResponse>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The name of the agent to update or create intents in.
    ///              Format: `projects/<Project ID>/agent`.
    pub fn agent_intents_batch_update(&self, request: GoogleCloudDialogflowV2beta1BatchUpdateIntentsRequest, parent: &str) -> ProjectAgentIntentBatchUpdateCall<'a, C, A> {
        ProjectAgentIntentBatchUpdateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified conversation profile.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the conversation profile to delete.
    ///            Format: `projects/<Project ID>/conversationProfiles/<Conversation Profile
    ///            ID>`.
    pub fn conversation_profiles_delete(&self, name: &str) -> ProjectConversationProfileDeleteCall<'a, C, A> {
        ProjectConversationProfileDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified knowledge base.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the knowledge base to retrieve.
    ///            Format `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    pub fn agent_knowledge_bases_get(&self, name: &str) -> ProjectAgentKnowledgeBaseGetCall<'a, C, A> {
        ProjectAgentKnowledgeBaseGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Restores the specified agent from a ZIP file.
    /// 
    /// Replaces the current agent version with a new one. All the intents and
    /// entity types in the older version are deleted.
    /// 
    /// 
    /// Operation <response: google.protobuf.Empty,
    ///            metadata: google.protobuf.Struct>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The project that the agent to restore is associated with.
    ///              Format: `projects/<Project ID>`.
    pub fn agent_restore(&self, request: GoogleCloudDialogflowV2beta1RestoreAgentRequest, parent: &str) -> ProjectAgentRestoreCall<'a, C, A> {
        ProjectAgentRestoreCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified context.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The unique identifier of the context. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`,
    ///            or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/contexts/<Context ID>`. The `Context ID` is
    ///            always converted to lowercase. If `Environment ID` is not specified, we
    ///            assume default 'draft' environment. If `User ID` is not specified, we
    ///            assume default '-' user.
    pub fn agent_environments_users_sessions_contexts_patch(&self, request: GoogleCloudDialogflowV2beta1Context, name: &str) -> ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionContextPatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified session entity type.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The unique identifier of this session entity type. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    ///            Display Name>`, or
    ///            `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/entityTypes/<Entity Type Display Name>`.
    ///            If `Environment ID` is not specified, we assume default 'draft'
    ///            environment. If `User ID` is not specified, we assume default '-' user.
    ///            `<Entity Type Display Name>` must be the display name of an existing entity
    ///            type in the same agent that will be overridden or supplemented.
    pub fn agent_environments_users_sessions_entity_types_patch(&self, request: GoogleCloudDialogflowV2beta1SessionEntityType, name: &str) -> ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionEntityTypePatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a conversation profile in the specified project.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The project to create a conversation profile for.
    ///              Format: `projects/<Project ID>`.
    pub fn conversation_profiles_create(&self, request: GoogleCloudDialogflowV2beta1ConversationProfile, parent: &str) -> ProjectConversationProfileCreateCall<'a, C, A> {
        ProjectConversationProfileCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified context.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the context to delete. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    ///            or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    ///            not specified, we assume default 'draft' environment. If `User ID` is not
    ///            specified, we assume default '-' user.
    pub fn environments_users_conversations_contexts_delete(&self, name: &str) -> ProjectEnvironmentUserConversationContextDeleteCall<'a, C, A> {
        ProjectEnvironmentUserConversationContextDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified intent.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the intent.
    ///            Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    pub fn agent_intents_get(&self, name: &str) -> ProjectAgentIntentGetCall<'a, C, A> {
        ProjectAgentIntentGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _language_code: Default::default(),
            _intent_view: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all session entity types in the specified session.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The session to list all session entity types from.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    ///              sessions/<Session ID>`.
    ///              If `Environment ID` is not specified, we assume default 'draft'
    ///              environment. If `User ID` is not specified, we assume default '-' user.
    pub fn agent_environments_users_sessions_entity_types_list(&self, parent: &str) -> ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionEntityTypeListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a human agent assistant.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The resource name of the agent assistant.
    ///            Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    ///            ID>`.
    pub fn human_agent_assistants_get(&self, name: &str) -> ProjectHumanAgentAssistantGetCall<'a, C, A> {
        ProjectHumanAgentAssistantGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all contexts in the specified session.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The session to list all contexts from.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///              ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///              default 'draft' environment. If `User ID` is not specified, we assume
    ///              default '-' user.
    pub fn agent_environments_users_sessions_contexts_list(&self, parent: &str) -> ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionContextListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified conversation profile.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required for all methods except `create` (`create` populates the name
    ///            automatically).
    ///            The unique identifier of this conversation profile.
    ///            Format: `projects/<Project ID>/conversationProfiles/<Conversation Profile
    ///            ID>`.
    pub fn conversation_profiles_patch(&self, request: GoogleCloudDialogflowV2beta1ConversationProfile, name: &str) -> ProjectConversationProfilePatchCall<'a, C, A> {
        ProjectConversationProfilePatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all contexts in the specified session.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The session to list all contexts from.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///              ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///              default 'draft' environment. If `User ID` is not specified, we assume
    ///              default '-' user.
    pub fn agent_sessions_contexts_list(&self, parent: &str) -> ProjectAgentSessionContextListCall<'a, C, A> {
        ProjectAgentSessionContextListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified entity type.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the entity type.
    ///            Format: `projects/<Project ID>/agent/entityTypes/<EntityType ID>`.
    pub fn agent_entity_types_get(&self, name: &str) -> ProjectAgentEntityTypeGetCall<'a, C, A> {
        ProjectAgentEntityTypeGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _language_code: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all documents of the knowledge base.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The knowledge base to list all documents for.
    ///              Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    pub fn knowledge_bases_documents_list(&self, parent: &str) -> ProjectKnowledgeBaseDocumentListCall<'a, C, A> {
        ProjectKnowledgeBaseDocumentListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified document.
    /// 
    /// Operation <response: google.protobuf.Empty,
    ///            metadata: KnowledgeOperationMetadata>
    /// 
    /// # Arguments
    ///
    /// * `name` - The name of the document to delete.
    ///            Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
    ///            ID>/documents/<Document ID>`.
    pub fn knowledge_bases_documents_delete(&self, name: &str) -> ProjectKnowledgeBaseDocumentDeleteCall<'a, C, A> {
        ProjectKnowledgeBaseDocumentDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of agents.
    /// 
    /// Since there is at most one conversational agent per project, this method is
    /// useful primarily for listing all agents across projects the caller has
    /// access to. One can achieve that with a wildcard project collection id "-".
    /// Refer to [List
    /// Sub-Collections](https://cloud.google.com/apis/design/design_patterns#list_sub-collections).
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The project to list agents from.
    ///              Format: `projects/<Project ID or '-'>`.
    pub fn agent_search(&self, parent: &str) -> ProjectAgentSearchCall<'a, C, A> {
        ProjectAgentSearchCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified intent.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required for all methods except `create` (`create` populates the name
    ///            automatically.
    ///            The unique identifier of this intent.
    ///            Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    pub fn agent_intents_patch(&self, request: GoogleCloudDialogflowV2beta1Intent, name: &str) -> ProjectAgentIntentPatchCall<'a, C, A> {
        ProjectAgentIntentPatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _language_code: Default::default(),
            _intent_view: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified human agent assistant.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The resource name of the agent assistant.
    ///            Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    ///            ID>`.
    pub fn human_agent_assistants_delete(&self, name: &str) -> ProjectHumanAgentAssistantDeleteCall<'a, C, A> {
        ProjectHumanAgentAssistantDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes all active contexts in the specified session.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The name of the session to delete all contexts from. Format:
    ///              `projects/<Project ID>/agent/sessions/<Session ID>` or `projects/<Project
    ///              ID>/agent/environments/<Environment ID>/users/<User ID>/sessions/<Session
    ///              ID>`. If `Environment ID` is not specified we assume default 'draft'
    ///              environment. If `User ID` is not specified, we assume default '-' user.
    pub fn agent_environments_users_sessions_delete_contexts(&self, parent: &str) -> ProjectAgentEnvironmentUserSessionDeleteContextCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionDeleteContextCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified `PhoneNumber`.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The unique identifier of this phone number.
    ///            Format: `projects/<Project ID>/phoneNumbers/<PhoneNumber ID>`.
    pub fn phone_numbers_patch(&self, request: GoogleCloudDialogflowV2beta1PhoneNumber, name: &str) -> ProjectPhoneNumberPatchCall<'a, C, A> {
        ProjectPhoneNumberPatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all knowledge bases of the specified agent.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The project to list of knowledge bases for.
    ///              Format: `projects/<Project ID>`.
    pub fn knowledge_bases_list(&self, parent: &str) -> ProjectKnowledgeBaseListCall<'a, C, A> {
        ProjectKnowledgeBaseListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes all active contexts in the specified session.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The name of the session to delete all contexts from. Format:
    ///              `projects/<Project ID>/agent/sessions/<Session ID>` or `projects/<Project
    ///              ID>/agent/environments/<Environment ID>/users/<User ID>/sessions/<Session
    ///              ID>`. If `Environment ID` is not specified we assume default 'draft'
    ///              environment. If `User ID` is not specified, we assume default '-' user.
    pub fn agent_sessions_delete_contexts(&self, parent: &str) -> ProjectAgentSessionDeleteContextCall<'a, C, A> {
        ProjectAgentSessionDeleteContextCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified document.
    /// 
    /// Operation <response: google.protobuf.Empty,
    ///            metadata: KnowledgeOperationMetadata>
    /// 
    /// # Arguments
    ///
    /// * `name` - The name of the document to delete.
    ///            Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
    ///            ID>/documents/<Document ID>`.
    pub fn agent_knowledge_bases_documents_delete(&self, name: &str) -> ProjectAgentKnowledgeBaseDocumentDeleteCall<'a, C, A> {
        ProjectAgentKnowledgeBaseDocumentDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes entity types in the specified agent.
    /// 
    /// Operation <response: google.protobuf.Empty,
    ///            metadata: google.protobuf.Struct>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The name of the agent to delete all entities types for. Format:
    ///              `projects/<Project ID>/agent`.
    pub fn agent_entity_types_batch_delete(&self, request: GoogleCloudDialogflowV2beta1BatchDeleteEntityTypesRequest, parent: &str) -> ProjectAgentEntityTypeBatchDeleteCall<'a, C, A> {
        ProjectAgentEntityTypeBatchDeleteCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Imports the specified agent from a ZIP file.
    /// 
    /// Uploads new intents and entity types without deleting the existing ones.
    /// Intents and entity types with the same name are replaced with the new
    /// versions from ImportAgentRequest.
    /// 
    /// 
    /// Operation <response: google.protobuf.Empty,
    ///            metadata: google.protobuf.Struct>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The project that the agent to import is associated with.
    ///              Format: `projects/<Project ID>`.
    pub fn agent_import(&self, request: GoogleCloudDialogflowV2beta1ImportAgentRequest, parent: &str) -> ProjectAgentImportCall<'a, C, A> {
        ProjectAgentImportCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a context.
    /// 
    /// If the specified context already exists, overrides the context.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The session to create a context for.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///              ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///              default 'draft' environment. If `User ID` is not specified, we assume
    ///              default '-' user.
    pub fn environments_users_conversations_contexts_create(&self, request: GoogleCloudDialogflowV2beta1Context, parent: &str) -> ProjectEnvironmentUserConversationContextCreateCall<'a, C, A> {
        ProjectEnvironmentUserConversationContextCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified context.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The unique identifier of the context. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`,
    ///            or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/contexts/<Context ID>`. The `Context ID` is
    ///            always converted to lowercase. If `Environment ID` is not specified, we
    ///            assume default 'draft' environment. If `User ID` is not specified, we
    ///            assume default '-' user.
    pub fn environments_users_conversations_contexts_patch(&self, request: GoogleCloudDialogflowV2beta1Context, name: &str) -> ProjectEnvironmentUserConversationContextPatchCall<'a, C, A> {
        ProjectEnvironmentUserConversationContextPatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all knowledge bases of the specified agent.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The project to list of knowledge bases for.
    ///              Format: `projects/<Project ID>`.
    pub fn agent_knowledge_bases_list(&self, parent: &str) -> ProjectAgentKnowledgeBaseListCall<'a, C, A> {
        ProjectAgentKnowledgeBaseListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates or creates multiple entities in the specified entity type. This
    /// method does not affect entities in the entity type that aren't explicitly
    /// specified in the request.
    /// 
    /// Operation <response: google.protobuf.Empty,
    ///            metadata: google.protobuf.Struct>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The name of the entity type to update or create entities in.
    ///              Format: `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    pub fn agent_entity_types_entities_batch_update(&self, request: GoogleCloudDialogflowV2beta1BatchUpdateEntitiesRequest, parent: &str) -> ProjectAgentEntityTypeEntityBatchUpdateCall<'a, C, A> {
        ProjectAgentEntityTypeEntityBatchUpdateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a context.
    /// 
    /// If the specified context already exists, overrides the context.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The session to create a context for.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///              ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///              default 'draft' environment. If `User ID` is not specified, we assume
    ///              default '-' user.
    pub fn agent_sessions_contexts_create(&self, request: GoogleCloudDialogflowV2beta1Context, parent: &str) -> ProjectAgentSessionContextCreateCall<'a, C, A> {
        ProjectAgentSessionContextCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all session entity types in the specified session.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The session to list all session entity types from.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    ///              sessions/<Session ID>`.
    ///              If `Environment ID` is not specified, we assume default 'draft'
    ///              environment. If `User ID` is not specified, we assume default '-' user.
    pub fn agent_sessions_entity_types_list(&self, parent: &str) -> ProjectAgentSessionEntityTypeListCall<'a, C, A> {
        ProjectAgentSessionEntityTypeListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Cancels an `PhoneNumberOrder`.
    /// Returns an error if the order is in state
    /// IN_PROGRESS or
    /// COMPLETED.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The unique identifier of the order to delete.
    ///            Format: `projects/<Project ID>/phoneNumberOrders/<Order ID>`.
    pub fn phone_number_orders_cancel(&self, request: GoogleCloudDialogflowV2beta1CancelPhoneNumberOrderRequest, name: &str) -> ProjectPhoneNumberOrderCancelCall<'a, C, A> {
        ProjectPhoneNumberOrderCancelCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified knowledge base.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the knowledge base to retrieve.
    ///            Format `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    pub fn knowledge_bases_get(&self, name: &str) -> ProjectKnowledgeBaseGetCall<'a, C, A> {
        ProjectKnowledgeBaseGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified human agent assistant.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required for all methods except `create` (`create` populates the name
    ///            automatically).
    ///            The unique identifier of human agent assistant.
    ///            Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    ///            ID>`.
    pub fn human_agent_assistants_patch(&self, request: GoogleCloudDialogflowV2beta1HumanAgentAssistant, name: &str) -> ProjectHumanAgentAssistantPatchCall<'a, C, A> {
        ProjectHumanAgentAssistantPatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Processes a natural language query and returns structured, actionable data
    /// as a result. This method is not idempotent, because it may cause contexts
    /// and session entity types to be updated, which in turn might affect
    /// results of future queries.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `session` - Required. The name of the session this query is sent to. Format:
    ///               `projects/<Project ID>/agent/sessions/<Session ID>`, or
    ///               `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///               ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///               default 'draft' environment. If `User ID` is not specified, we are using
    ///               "-". It’s up to the API caller to choose an appropriate `Session ID` and
    ///               `User Id`. They can be a random numbers or some type of user and session
    ///               identifiers (preferably hashed). The length of the `Session ID` and
    ///               `User ID` must not exceed 36 characters.
    pub fn agent_environments_users_sessions_detect_intent(&self, request: GoogleCloudDialogflowV2beta1DetectIntentRequest, session: &str) -> ProjectAgentEnvironmentUserSessionDetectIntentCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionDetectIntentCall {
            hub: self.hub,
            _request: request,
            _session: session.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Requests deletion of a `PhoneNumber`. The `PhoneNumber` is moved into the
    /// DELETE_REQUESTED state
    /// immediately, and is deleted approximately 30 days later. This method may
    /// only be called on a `PhoneNumber` in the
    /// ACTIVE state.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The unique identifier of the `PhoneNumber` to delete.
    ///            Format: `projects/<Project ID>/phoneNumbers/<PhoneNumber ID>`.
    pub fn phone_numbers_delete(&self, name: &str) -> ProjectPhoneNumberDeleteCall<'a, C, A> {
        ProjectPhoneNumberDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified entity type.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the entity type to delete.
    ///            Format: `projects/<Project ID>/agent/entityTypes/<EntityType ID>`.
    pub fn agent_entity_types_delete(&self, name: &str) -> ProjectAgentEntityTypeDeleteCall<'a, C, A> {
        ProjectAgentEntityTypeDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified context.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The unique identifier of the context. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`,
    ///            or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/contexts/<Context ID>`. The `Context ID` is
    ///            always converted to lowercase. If `Environment ID` is not specified, we
    ///            assume default 'draft' environment. If `User ID` is not specified, we
    ///            assume default '-' user.
    pub fn agent_sessions_contexts_patch(&self, request: GoogleCloudDialogflowV2beta1Context, name: &str) -> ProjectAgentSessionContextPatchCall<'a, C, A> {
        ProjectAgentSessionContextPatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified context.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the context. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    ///            or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    ///            not specified, we assume default 'draft' environment. If `User ID` is not
    ///            specified, we assume default '-' user.
    pub fn agent_sessions_contexts_get(&self, name: &str) -> ProjectAgentSessionContextGetCall<'a, C, A> {
        ProjectAgentSessionContextGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves a conversation participant.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the participant. Format:
    ///            `projects/<Project ID>/conversations/<Conversation
    ///            ID>/participants/<Participant ID>`.
    pub fn conversations_participants_get(&self, name: &str) -> ProjectConversationParticipantGetCall<'a, C, A> {
        ProjectConversationParticipantGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Trains the specified agent.
    /// 
    /// 
    /// Operation <response: google.protobuf.Empty,
    ///            metadata: google.protobuf.Struct>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The project that the agent to train is associated with.
    ///              Format: `projects/<Project ID>`.
    pub fn agent_train(&self, request: GoogleCloudDialogflowV2beta1TrainAgentRequest, parent: &str) -> ProjectAgentTrainCall<'a, C, A> {
        ProjectAgentTrainCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified context.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the context to delete. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    ///            or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    ///            not specified, we assume default 'draft' environment. If `User ID` is not
    ///            specified, we assume default '-' user.
    pub fn agent_sessions_contexts_delete(&self, name: &str) -> ProjectAgentSessionContextDeleteCall<'a, C, A> {
        ProjectAgentSessionContextDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all contexts in the specified session.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The session to list all contexts from.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///              ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///              default 'draft' environment. If `User ID` is not specified, we assume
    ///              default '-' user.
    pub fn environments_users_conversations_contexts_list(&self, parent: &str) -> ProjectEnvironmentUserConversationContextListCall<'a, C, A> {
        ProjectEnvironmentUserConversationContextListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified context.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the context. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    ///            or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    ///            not specified, we assume default 'draft' environment. If `User ID` is not
    ///            specified, we assume default '-' user.
    pub fn environments_users_conversations_contexts_get(&self, name: &str) -> ProjectEnvironmentUserConversationContextGetCall<'a, C, A> {
        ProjectEnvironmentUserConversationContextGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all participants in the specified conversation.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The conversation to list all contexts from.
    ///              Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    pub fn conversations_participants_list(&self, parent: &str) -> ProjectConversationParticipantListCall<'a, C, A> {
        ProjectConversationParticipantListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified context.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the context to delete. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    ///            or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    ///            not specified, we assume default 'draft' environment. If `User ID` is not
    ///            specified, we assume default '-' user.
    pub fn agent_environments_users_sessions_contexts_delete(&self, name: &str) -> ProjectAgentEnvironmentUserSessionContextDeleteCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionContextDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified session entity type.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the entity type to delete. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    ///            Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    ///            ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    ///            Name>`. If `Environment ID` is not specified, we assume default 'draft'
    ///            environment. If `User ID` is not specified, we assume default '-' user.
    pub fn agent_environments_users_sessions_entity_types_delete(&self, name: &str) -> ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates an order to request phone numbers be added to a project.
    /// The initial `LifecycleState` of a newly created order is
    /// PENDING.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. Resource identifier of the project requesting the orders.
    ///              Format: `projects/<Project ID>`.
    pub fn phone_number_orders_create(&self, request: GoogleCloudDialogflowV2beta1PhoneNumberOrder, parent: &str) -> ProjectPhoneNumberOrderCreateCall<'a, C, A> {
        ProjectPhoneNumberOrderCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Lists of all `PhoneNumberOrder` resources in the specified project.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The project to list all orders from.
    ///              Format: `projects/<Project ID>`.
    pub fn phone_number_orders_list(&self, parent: &str) -> ProjectPhoneNumberOrderListCall<'a, C, A> {
        ProjectPhoneNumberOrderListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Processes a natural language query and returns structured, actionable data
    /// as a result. This method is not idempotent, because it may cause contexts
    /// and session entity types to be updated, which in turn might affect
    /// results of future queries.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `session` - Required. The name of the session this query is sent to. Format:
    ///               `projects/<Project ID>/agent/sessions/<Session ID>`, or
    ///               `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///               ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///               default 'draft' environment. If `User ID` is not specified, we are using
    ///               "-". It’s up to the API caller to choose an appropriate `Session ID` and
    ///               `User Id`. They can be a random numbers or some type of user and session
    ///               identifiers (preferably hashed). The length of the `Session ID` and
    ///               `User ID` must not exceed 36 characters.
    pub fn agent_sessions_detect_intent(&self, request: GoogleCloudDialogflowV2beta1DetectIntentRequest, session: &str) -> ProjectAgentSessionDetectIntentCall<'a, C, A> {
        ProjectAgentSessionDetectIntentCall {
            hub: self.hub,
            _request: request,
            _session: session.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a new document.
    /// 
    /// Operation <response: Document,
    ///            metadata: KnowledgeOperationMetadata>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The knoweldge base to create a document for.
    ///              Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    pub fn knowledge_bases_documents_create(&self, request: GoogleCloudDialogflowV2beta1Document, parent: &str) -> ProjectKnowledgeBaseDocumentCreateCall<'a, C, A> {
        ProjectKnowledgeBaseDocumentCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specific conversation.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the conversation. Format:
    ///            `projects/<Project ID>/conversations/<Conversation ID>`.
    pub fn conversations_get(&self, name: &str) -> ProjectConversationGetCall<'a, C, A> {
        ProjectConversationGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified knowledge base.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the knowledge base to delete.
    ///            Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    pub fn knowledge_bases_delete(&self, name: &str) -> ProjectKnowledgeBaseDeleteCall<'a, C, A> {
        ProjectKnowledgeBaseDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _force: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified `PhoneNumberOrder` resource.
    /// Returns an error if the order is in state
    /// IN_PROGRESS or
    /// COMPLETED.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The unique identifier of this order.
    ///            Format: `projects/<Project ID>/phoneNumberOrders/<Order ID>`.
    pub fn phone_number_orders_patch(&self, request: GoogleCloudDialogflowV2beta1PhoneNumberOrder, name: &str) -> ProjectPhoneNumberOrderPatchCall<'a, C, A> {
        ProjectPhoneNumberOrderPatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes all active contexts in the specified session.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The name of the session to delete all contexts from. Format:
    ///              `projects/<Project ID>/agent/sessions/<Session ID>` or `projects/<Project
    ///              ID>/agent/environments/<Environment ID>/users/<User ID>/sessions/<Session
    ///              ID>`. If `Environment ID` is not specified we assume default 'draft'
    ///              environment. If `User ID` is not specified, we assume default '-' user.
    pub fn environments_users_conversations_delete_contexts(&self, parent: &str) -> ProjectEnvironmentUserConversationDeleteContextCall<'a, C, A> {
        ProjectEnvironmentUserConversationDeleteContextCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Gets the latest state of a long-running operation.  Clients can use this
    /// method to poll the operation result at intervals as recommended by the API
    /// service.
    /// 
    /// # Arguments
    ///
    /// * `name` - The name of the operation resource.
    pub fn operations_get(&self, name: &str) -> ProjectOperationGetCall<'a, C, A> {
        ProjectOperationGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a new participant in a conversation.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. Resource identifier of the conversation adding the participant.
    ///              Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    pub fn conversations_participants_create(&self, request: GoogleCloudDialogflowV2beta1Participant, parent: &str) -> ProjectConversationParticipantCreateCall<'a, C, A> {
        ProjectConversationParticipantCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Sets a phone number for this converstion to connect to.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - The name of this conversation.
    ///            Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    pub fn conversations_add_conversation_phone_number(&self, request: GoogleCloudDialogflowV2beta1AddConversationPhoneNumberRequest, name: &str) -> ProjectConversationAddConversationPhoneNumberCall<'a, C, A> {
        ProjectConversationAddConversationPhoneNumberCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all conversation profiles in the specified project.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The project to list all conversation profiles from.
    ///              Format: `projects/<Project ID>`.
    pub fn conversation_profiles_list(&self, parent: &str) -> ProjectConversationProfileListCall<'a, C, A> {
        ProjectConversationProfileListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a session entity type.
    /// 
    /// If the specified session entity type already exists, overrides the
    /// session entity type.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The session to create a session entity type for.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    ///              sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///              default 'draft' environment. If `User ID` is not specified, we assume
    ///              default '-' user.
    pub fn agent_environments_users_sessions_entity_types_create(&self, request: GoogleCloudDialogflowV2beta1SessionEntityType, parent: &str) -> ProjectAgentEnvironmentUserSessionEntityTypeCreateCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionEntityTypeCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a context.
    /// 
    /// If the specified context already exists, overrides the context.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The session to create a context for.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///              ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///              default 'draft' environment. If `User ID` is not specified, we assume
    ///              default '-' user.
    pub fn agent_environments_users_sessions_contexts_create(&self, request: GoogleCloudDialogflowV2beta1Context, parent: &str) -> ProjectAgentEnvironmentUserSessionContextCreateCall<'a, C, A> {
        ProjectAgentEnvironmentUserSessionContextCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates an entity type in the specified agent.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The agent to create a entity type for.
    ///              Format: `projects/<Project ID>/agent`.
    pub fn agent_entity_types_create(&self, request: GoogleCloudDialogflowV2beta1EntityType, parent: &str) -> ProjectAgentEntityTypeCreateCall<'a, C, A> {
        ProjectAgentEntityTypeCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _language_code: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Adds a text (chat, for example), or audio (phone recording, for example)
    /// message from a participan  into the conversation.
    /// Note: This method is only available through the gRPC API (not REST).
    /// 
    /// The top-level message sent to the client by the server is
    /// `StreamingAnalyzeContentResponse`. Multiple response messages can be
    /// returned in order. The first one or more messages contain the
    /// `recognition_result` field. Each result represents a more complete
    /// transcript of what the user said. The next message contains the
    /// `reply_text` field and potentially the `reply_audio` field. The message can
    /// also contain the `automated_agent_reply` field.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `participant` - Required. The name of the participant this text comes from.
    ///                   Format: `projects/<Project ID>/conversations/<Conversation
    ///                   ID>/participants/<Participant ID>`.
    pub fn conversations_participants_streaming_analyze_content(&self, request: GoogleCloudDialogflowV2beta1StreamingAnalyzeContentRequest, participant: &str) -> ProjectConversationParticipantStreamingAnalyzeContentCall<'a, C, A> {
        ProjectConversationParticipantStreamingAnalyzeContentCall {
            hub: self.hub,
            _request: request,
            _participant: participant.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes entities in the specified entity type.
    /// 
    /// Operation <response: google.protobuf.Empty,
    ///            metadata: google.protobuf.Struct>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The name of the entity type to delete entries for. Format:
    ///              `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    pub fn agent_entity_types_entities_batch_delete(&self, request: GoogleCloudDialogflowV2beta1BatchDeleteEntitiesRequest, parent: &str) -> ProjectAgentEntityTypeEntityBatchDeleteCall<'a, C, A> {
        ProjectAgentEntityTypeEntityBatchDeleteCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a new document.
    /// 
    /// Operation <response: Document,
    ///            metadata: KnowledgeOperationMetadata>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The knoweldge base to create a document for.
    ///              Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    pub fn agent_knowledge_bases_documents_create(&self, request: GoogleCloudDialogflowV2beta1Document, parent: &str) -> ProjectAgentKnowledgeBaseDocumentCreateCall<'a, C, A> {
        ProjectAgentKnowledgeBaseDocumentCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified entity type.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required for all methods except `create` (`create` populates the name
    ///            automatically.
    ///            The unique identifier of the entity type. Format:
    ///            `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    pub fn agent_entity_types_patch(&self, request: GoogleCloudDialogflowV2beta1EntityType, name: &str) -> ProjectAgentEntityTypePatchCall<'a, C, A> {
        ProjectAgentEntityTypePatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _language_code: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves suggestions for live agents.
    /// 
    /// This method should be used by human agent client software to fetch
    /// suggestions in real-time, while the conversation with an end user is in
    /// progress. The functionality is implemented in terms of the
    /// [list pagination](/apis/design/design_patterns#list_pagination)
    /// design pattern. The client app should use the `next_page_token` field
    /// to fetch the next batch of suggestions.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The name of the conversation participant for whom to fetch
    ///              suggestions.
    ///              Format: `projects/<Project ID>/conversations/<Conversation
    ///              ID>/participants/<Participant ID>`.
    pub fn conversations_participants_suggestions_list(&self, parent: &str) -> ProjectConversationParticipantSuggestionListCall<'a, C, A> {
        ProjectConversationParticipantSuggestionListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified agent.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The project that the agent to fetch is associated with.
    ///              Format: `projects/<Project ID>`.
    pub fn get_agent(&self, parent: &str) -> ProjectGetAgentCall<'a, C, A> {
        ProjectGetAgentCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a knowledge base.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The project to create a knowledge base for.
    ///              Format: `projects/<Project ID>`.
    pub fn knowledge_bases_create(&self, request: GoogleCloudDialogflowV2beta1KnowledgeBase, parent: &str) -> ProjectKnowledgeBaseCreateCall<'a, C, A> {
        ProjectKnowledgeBaseCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all documents of the knowledge base.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The knowledge base to list all documents for.
    ///              Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    pub fn agent_knowledge_bases_documents_list(&self, parent: &str) -> ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A> {
        ProjectAgentKnowledgeBaseDocumentListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Completes the specified conversation. Finished conversations are purged
    /// from the database after 30 days.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. Resource identifier of the conversation to close.
    ///            Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    pub fn conversations_complete(&self, request: GoogleCloudDialogflowV2beta1CompleteConversationRequest, name: &str) -> ProjectConversationCompleteCall<'a, C, A> {
        ProjectConversationCompleteCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified intent and its direct or indirect followup intents.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the intent to delete. If this intent has direct or
    ///            indirect followup intents, we also delete them.
    ///            Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    pub fn agent_intents_delete(&self, name: &str) -> ProjectAgentIntentDeleteCall<'a, C, A> {
        ProjectAgentIntentDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Lists messages that belong to a given conversation.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The name of the conversation to list messages for.
    ///              Format: `projects/<Project ID>/conversations/<Conversation ID>`
    pub fn conversations_messages_list(&self, parent: &str) -> ProjectConversationMessageListCall<'a, C, A> {
        ProjectConversationMessageListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified knowledge base.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the knowledge base to delete.
    ///            Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    pub fn agent_knowledge_bases_delete(&self, name: &str) -> ProjectAgentKnowledgeBaseDeleteCall<'a, C, A> {
        ProjectAgentKnowledgeBaseDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _force: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified conversation profile.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The resource name of the conversation profile.
    ///            Format: `projects/<Project ID>/conversationProfiles/<Conversation Profile
    ///            ID>`.
    pub fn conversation_profiles_get(&self, name: &str) -> ProjectConversationProfileGetCall<'a, C, A> {
        ProjectConversationProfileGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a new conversation. Conversation are auto-completed after 24 hours.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. Resource identifier of the project creating the conversation.
    ///              Format: `projects/<Project ID>`.
    pub fn conversations_create(&self, request: GoogleCloudDialogflowV2beta1Conversation, parent: &str) -> ProjectConversationCreateCall<'a, C, A> {
        ProjectConversationCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all conversations in the specified project.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The project from which to list all conversation.
    ///              Format: `projects/<Project ID>`.
    pub fn conversations_list(&self, parent: &str) -> ProjectConversationListCall<'a, C, A> {
        ProjectConversationListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _filter: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all phone numbers in the specified project.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The project to list all `PhoneNumber` resources from.
    ///              Format: `projects/<Project ID>`.
    pub fn phone_numbers_list(&self, parent: &str) -> ProjectPhoneNumberListCall<'a, C, A> {
        ProjectPhoneNumberListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _show_deleted: Default::default(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all human agent assistants.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The project to list all agent assistants from.
    ///              Format: `projects/<Project ID>`.
    pub fn human_agent_assistants_list(&self, parent: &str) -> ProjectHumanAgentAssistantListCall<'a, C, A> {
        ProjectHumanAgentAssistantListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all intents in the specified agent.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The agent to list all intents from.
    ///              Format: `projects/<Project ID>/agent`.
    pub fn agent_intents_list(&self, parent: &str) -> ProjectAgentIntentListCall<'a, C, A> {
        ProjectAgentIntentListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _language_code: Default::default(),
            _intent_view: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Adds a text (chat, for example), or audio (phone recording, for example)
    /// message from a participan  into the conversation.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `participant` - Required. The name of the participant this text comes from.
    ///                   Format: `projects/<Project ID>/conversations/<Conversation
    ///                   ID>/participants/<Participant ID>`.
    pub fn conversations_participants_analyze_content(&self, request: GoogleCloudDialogflowV2beta1AnalyzeContentRequest, participant: &str) -> ProjectConversationParticipantAnalyzeContentCall<'a, C, A> {
        ProjectConversationParticipantAnalyzeContentCall {
            hub: self.hub,
            _request: request,
            _participant: participant.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a session entity type.
    /// 
    /// If the specified session entity type already exists, overrides the
    /// session entity type.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The session to create a session entity type for.
    ///              Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    ///              `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    ///              sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    ///              default 'draft' environment. If `User ID` is not specified, we assume
    ///              default '-' user.
    pub fn agent_sessions_entity_types_create(&self, request: GoogleCloudDialogflowV2beta1SessionEntityType, parent: &str) -> ProjectAgentSessionEntityTypeCreateCall<'a, C, A> {
        ProjectAgentSessionEntityTypeCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns a specific `PhoneNumberOrder`.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The unique identifier of the order to retrieve.
    ///            Format: `projects/<Project ID>/phoneNumberOrders/<Order ID>`.
    pub fn phone_number_orders_get(&self, name: &str) -> ProjectPhoneNumberOrderGetCall<'a, C, A> {
        ProjectPhoneNumberOrderGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates multiple new entities in the specified entity type.
    /// 
    /// Operation <response: google.protobuf.Empty>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The name of the entity type to create entities in. Format:
    ///              `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    pub fn agent_entity_types_entities_batch_create(&self, request: GoogleCloudDialogflowV2beta1BatchCreateEntitiesRequest, parent: &str) -> ProjectAgentEntityTypeEntityBatchCreateCall<'a, C, A> {
        ProjectAgentEntityTypeEntityBatchCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified document.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the document to retrieve.
    ///            Format `projects/<Project ID>/knowledgeBases/<Knowledge Base
    ///            ID>/documents/<Document ID>`.
    pub fn agent_knowledge_bases_documents_get(&self, name: &str) -> ProjectAgentKnowledgeBaseDocumentGetCall<'a, C, A> {
        ProjectAgentKnowledgeBaseDocumentGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes intents in the specified agent.
    /// 
    /// Operation <response: google.protobuf.Empty>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The name of the agent to delete all entities types for. Format:
    ///              `projects/<Project ID>/agent`.
    pub fn agent_intents_batch_delete(&self, request: GoogleCloudDialogflowV2beta1BatchDeleteIntentsRequest, parent: &str) -> ProjectAgentIntentBatchDeleteCall<'a, C, A> {
        ProjectAgentIntentBatchDeleteCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Cancels the deletion request for a `PhoneNumber`. This method may only be
    /// called on a `PhoneNumber` in the
    /// DELETE_REQUESTED state.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The unique identifier of the `PhoneNumber` to delete.
    ///            Format: `projects/<Project ID>/phoneNumbers/<PhoneNumber ID>`.
    pub fn phone_numbers_undelete(&self, request: GoogleCloudDialogflowV2beta1UndeletePhoneNumberRequest, name: &str) -> ProjectPhoneNumberUndeleteCall<'a, C, A> {
        ProjectPhoneNumberUndeleteCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified document.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the document to retrieve.
    ///            Format `projects/<Project ID>/knowledgeBases/<Knowledge Base
    ///            ID>/documents/<Document ID>`.
    pub fn knowledge_bases_documents_get(&self, name: &str) -> ProjectKnowledgeBaseDocumentGetCall<'a, C, A> {
        ProjectKnowledgeBaseDocumentGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Updates the specified session entity type.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The unique identifier of this session entity type. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    ///            Display Name>`, or
    ///            `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    ///            ID>/sessions/<Session ID>/entityTypes/<Entity Type Display Name>`.
    ///            If `Environment ID` is not specified, we assume default 'draft'
    ///            environment. If `User ID` is not specified, we assume default '-' user.
    ///            `<Entity Type Display Name>` must be the display name of an existing entity
    ///            type in the same agent that will be overridden or supplemented.
    pub fn agent_sessions_entity_types_patch(&self, request: GoogleCloudDialogflowV2beta1SessionEntityType, name: &str) -> ProjectAgentSessionEntityTypePatchCall<'a, C, A> {
        ProjectAgentSessionEntityTypePatchCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _update_mask: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Uses the specified human agent assistant to come up with suggestions
    /// (relevant articles and FAQs) on how to respond to a given conversation.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `name` - Required. The resource name of the agent assistant.
    ///            Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    ///            ID>`.
    pub fn human_agent_assistants_compile_suggestions(&self, request: GoogleCloudDialogflowV2beta1CompileSuggestionsRequest, name: &str) -> ProjectHumanAgentAssistantCompileSuggestionCall<'a, C, A> {
        ProjectHumanAgentAssistantCompileSuggestionCall {
            hub: self.hub,
            _request: request,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Retrieves the specified session entity type.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the session entity type. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    ///            Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    ///            ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    ///            Name>`. If `Environment ID` is not specified, we assume default 'draft'
    ///            environment. If `User ID` is not specified, we assume default '-' user.
    pub fn agent_sessions_entity_types_get(&self, name: &str) -> ProjectAgentSessionEntityTypeGetCall<'a, C, A> {
        ProjectAgentSessionEntityTypeGetCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Exports the specified agent to a ZIP file.
    /// 
    /// 
    /// Operation <response: ExportAgentResponse,
    ///            metadata: google.protobuf.Struct>
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The project that the agent to export is associated with.
    ///              Format: `projects/<Project ID>`.
    pub fn agent_export(&self, request: GoogleCloudDialogflowV2beta1ExportAgentRequest, parent: &str) -> ProjectAgentExportCall<'a, C, A> {
        ProjectAgentExportCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Returns the list of all entity types in the specified agent.
    /// 
    /// # Arguments
    ///
    /// * `parent` - Required. The agent to list all entity types from.
    ///              Format: `projects/<Project ID>/agent`.
    pub fn agent_entity_types_list(&self, parent: &str) -> ProjectAgentEntityTypeListCall<'a, C, A> {
        ProjectAgentEntityTypeListCall {
            hub: self.hub,
            _parent: parent.to_string(),
            _page_token: Default::default(),
            _page_size: Default::default(),
            _language_code: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Deletes the specified session entity type.
    /// 
    /// # Arguments
    ///
    /// * `name` - Required. The name of the entity type to delete. Format:
    ///            `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    ///            Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    ///            ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    ///            Name>`. If `Environment ID` is not specified, we assume default 'draft'
    ///            environment. If `User ID` is not specified, we assume default '-' user.
    pub fn agent_sessions_entity_types_delete(&self, name: &str) -> ProjectAgentSessionEntityTypeDeleteCall<'a, C, A> {
        ProjectAgentSessionEntityTypeDeleteCall {
            hub: self.hub,
            _name: name.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates a human agent assistant.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The project to create a agent assistant for.
    ///              Format: `projects/<Project ID>`.
    pub fn human_agent_assistants_create(&self, request: GoogleCloudDialogflowV2beta1HumanAgentAssistant, parent: &str) -> ProjectHumanAgentAssistantCreateCall<'a, C, A> {
        ProjectHumanAgentAssistantCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Creates an intent in the specified agent.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `parent` - Required. The agent to create a intent for.
    ///              Format: `projects/<Project ID>/agent`.
    pub fn agent_intents_create(&self, request: GoogleCloudDialogflowV2beta1Intent, parent: &str) -> ProjectAgentIntentCreateCall<'a, C, A> {
        ProjectAgentIntentCreateCall {
            hub: self.hub,
            _request: request,
            _parent: parent.to_string(),
            _language_code: Default::default(),
            _intent_view: Default::default(),
            _delegate: Default::default(),
            _scopes: Default::default(),
            _additional_params: Default::default(),
        }
    }
}





// ###################
// CallBuilders   ###
// #################

/// Retrieves the specified session entity type.
///
/// A builder for the *agent.environments.users.sessions.entityTypes.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_entity_types_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionEntityTypeGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionEntityTypeGetCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionEntityTypeGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1SessionEntityType), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.entityTypes.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the session entity type. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    /// ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    /// Name>`. If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionEntityTypeGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionEntityTypeGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionEntityTypeGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionEntityTypeGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified context.
///
/// A builder for the *agent.environments.users.sessions.contexts.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_contexts_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionContextGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionContextGetCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionContextGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Context), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.contexts.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the context. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    /// not specified, we assume default 'draft' environment. If `User ID` is not
    /// specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionContextGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionContextGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionContextGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionContextGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates/Creates multiple entity types in the specified agent.
/// 
/// Operation <response: BatchUpdateEntityTypesResponse,
///            metadata: google.protobuf.Struct>
///
/// A builder for the *agent.entityTypes.batchUpdate* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1BatchUpdateEntityTypesRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1BatchUpdateEntityTypesRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_batch_update(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypeBatchUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1BatchUpdateEntityTypesRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypeBatchUpdateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypeBatchUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.batchUpdate",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entityTypes:batchUpdate";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1BatchUpdateEntityTypesRequest) -> ProjectAgentEntityTypeBatchUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the agent to update or create entity types in.
    /// Format: `projects/<Project ID>/agent`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEntityTypeBatchUpdateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypeBatchUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypeBatchUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypeBatchUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a knowledge base.
///
/// A builder for the *agent.knowledgeBases.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1KnowledgeBase;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1KnowledgeBase::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_knowledge_bases_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentKnowledgeBaseCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1KnowledgeBase,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentKnowledgeBaseCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentKnowledgeBaseCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1KnowledgeBase), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.knowledgeBases.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/knowledgeBases";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1KnowledgeBase) -> ProjectAgentKnowledgeBaseCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The project to create a knowledge base for.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentKnowledgeBaseCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentKnowledgeBaseCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentKnowledgeBaseCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates/Creates multiple intents in the specified agent.
/// 
/// Operation <response: BatchUpdateIntentsResponse>
///
/// A builder for the *agent.intents.batchUpdate* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1BatchUpdateIntentsRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1BatchUpdateIntentsRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_intents_batch_update(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentIntentBatchUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1BatchUpdateIntentsRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentIntentBatchUpdateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentIntentBatchUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.intents.batchUpdate",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/intents:batchUpdate";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1BatchUpdateIntentsRequest) -> ProjectAgentIntentBatchUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the agent to update or create intents in.
    /// Format: `projects/<Project ID>/agent`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentIntentBatchUpdateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentIntentBatchUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentIntentBatchUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentIntentBatchUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified conversation profile.
///
/// A builder for the *conversationProfiles.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversation_profiles_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationProfileDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationProfileDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationProfileDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversationProfiles.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the conversation profile to delete.
    /// Format: `projects/<Project ID>/conversationProfiles/<Conversation Profile
    /// ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectConversationProfileDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationProfileDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationProfileDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationProfileDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified knowledge base.
///
/// A builder for the *agent.knowledgeBases.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_knowledge_bases_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentKnowledgeBaseGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentKnowledgeBaseGetCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentKnowledgeBaseGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1KnowledgeBase), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.knowledgeBases.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the knowledge base to retrieve.
    /// Format `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentKnowledgeBaseGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentKnowledgeBaseGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentKnowledgeBaseGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Restores the specified agent from a ZIP file.
/// 
/// Replaces the current agent version with a new one. All the intents and
/// entity types in the older version are deleted.
/// 
/// 
/// Operation <response: google.protobuf.Empty,
///            metadata: google.protobuf.Struct>
///
/// A builder for the *agent.restore* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1RestoreAgentRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1RestoreAgentRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_restore(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentRestoreCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1RestoreAgentRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentRestoreCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentRestoreCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.restore",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/agent:restore";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1RestoreAgentRequest) -> ProjectAgentRestoreCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The project that the agent to restore is associated with.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentRestoreCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentRestoreCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentRestoreCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentRestoreCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified context.
///
/// A builder for the *agent.environments.users.sessions.contexts.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Context;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Context::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_contexts_patch(req, "name")
///              .update_mask("labore")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Context,
    _name: String,
    _update_mask: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Context), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.contexts.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Context) -> ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The unique identifier of the context. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`,
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. The `Context ID` is
    /// always converted to lowercase. If `Environment ID` is not specified, we
    /// assume default 'draft' environment. If `User ID` is not specified, we
    /// assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to control which fields get updated.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionContextPatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified session entity type.
///
/// A builder for the *agent.environments.users.sessions.entityTypes.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1SessionEntityType;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1SessionEntityType::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_entity_types_patch(req, "name")
///              .update_mask("nonumy")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1SessionEntityType,
    _name: String,
    _update_mask: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1SessionEntityType), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.entityTypes.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1SessionEntityType) -> ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The unique identifier of this session entity type. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>`, or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/entityTypes/<Entity Type Display Name>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    /// 
    /// `<Entity Type Display Name>` must be the display name of an existing entity
    /// type in the same agent that will be overridden or supplemented.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to control which fields get updated.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionEntityTypePatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a conversation profile in the specified project.
///
/// A builder for the *conversationProfiles.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1ConversationProfile;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1ConversationProfile::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversation_profiles_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationProfileCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1ConversationProfile,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationProfileCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationProfileCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ConversationProfile), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversationProfiles.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/conversationProfiles";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1ConversationProfile) -> ProjectConversationProfileCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The project to create a conversation profile for.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectConversationProfileCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationProfileCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationProfileCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationProfileCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified context.
///
/// A builder for the *environments.users.conversations.contexts.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().environments_users_conversations_contexts_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectEnvironmentUserConversationContextDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectEnvironmentUserConversationContextDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectEnvironmentUserConversationContextDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.environments.users.conversations.contexts.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the context to delete. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    /// not specified, we assume default 'draft' environment. If `User ID` is not
    /// specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectEnvironmentUserConversationContextDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectEnvironmentUserConversationContextDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectEnvironmentUserConversationContextDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectEnvironmentUserConversationContextDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified intent.
///
/// A builder for the *agent.intents.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_intents_get("name")
///              .language_code("aliquyam")
///              .intent_view("ea")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentIntentGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _language_code: Option<String>,
    _intent_view: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentIntentGetCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentIntentGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Intent), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.intents.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._language_code {
            params.push(("languageCode", value.to_string()));
        }
        if let Some(value) = self._intent_view {
            params.push(("intentView", value.to_string()));
        }
        for &field in ["alt", "name", "languageCode", "intentView"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the intent.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentIntentGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The language to retrieve training phrases, parameters and rich
    /// messages for. If not specified, the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    ///
    /// Sets the *language code* query property to the given value.
    pub fn language_code(mut self, new_value: &str) -> ProjectAgentIntentGetCall<'a, C, A> {
        self._language_code = Some(new_value.to_string());
        self
    }
    /// Optional. The resource view to apply to the returned intent.
    ///
    /// Sets the *intent view* query property to the given value.
    pub fn intent_view(mut self, new_value: &str) -> ProjectAgentIntentGetCall<'a, C, A> {
        self._intent_view = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentIntentGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentIntentGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentIntentGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all session entity types in the specified session.
///
/// A builder for the *agent.environments.users.sessions.entityTypes.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_entity_types_list("parent")
///              .page_token("justo")
///              .page_size(-21)
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListSessionEntityTypesResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.entityTypes.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entityTypes";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The session to list all session entity types from.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    /// sessions/<Session ID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionEntityTypeListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a human agent assistant.
///
/// A builder for the *humanAgentAssistants.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().human_agent_assistants_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectHumanAgentAssistantGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectHumanAgentAssistantGetCall<'a, C, A> {}

impl<'a, C, A> ProjectHumanAgentAssistantGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1HumanAgentAssistant), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.humanAgentAssistants.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The resource name of the agent assistant.
    /// Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    /// ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectHumanAgentAssistantGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectHumanAgentAssistantGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectHumanAgentAssistantGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectHumanAgentAssistantGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all contexts in the specified session.
///
/// A builder for the *agent.environments.users.sessions.contexts.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_contexts_list("parent")
///              .page_token("diam")
///              .page_size(-55)
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListContextsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.contexts.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/contexts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The session to list all contexts from.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we assume
    /// default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionContextListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified conversation profile.
///
/// A builder for the *conversationProfiles.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1ConversationProfile;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1ConversationProfile::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversation_profiles_patch(req, "name")
///              .update_mask("et")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationProfilePatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1ConversationProfile,
    _name: String,
    _update_mask: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationProfilePatchCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationProfilePatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ConversationProfile), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversationProfiles.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1ConversationProfile) -> ProjectConversationProfilePatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required for all methods except `create` (`create` populates the name
    /// automatically).
    /// The unique identifier of this conversation profile.
    /// Format: `projects/<Project ID>/conversationProfiles/<Conversation Profile
    /// ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectConversationProfilePatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Required. The mask to control which fields to update.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectConversationProfilePatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationProfilePatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationProfilePatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationProfilePatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all contexts in the specified session.
///
/// A builder for the *agent.sessions.contexts.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_contexts_list("parent")
///              .page_token("aliquyam")
///              .page_size(-9)
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionContextListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionContextListCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionContextListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListContextsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.contexts.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/contexts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The session to list all contexts from.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we assume
    /// default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentSessionContextListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectAgentSessionContextListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectAgentSessionContextListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionContextListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionContextListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionContextListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified entity type.
///
/// A builder for the *agent.entityTypes.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_get("name")
///              .language_code("eos")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypeGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _language_code: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypeGetCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypeGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1EntityType), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._language_code {
            params.push(("languageCode", value.to_string()));
        }
        for &field in ["alt", "name", "languageCode"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the entity type.
    /// Format: `projects/<Project ID>/agent/entityTypes/<EntityType ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentEntityTypeGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The language to retrieve entity synonyms for. If not specified,
    /// the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    ///
    /// Sets the *language code* query property to the given value.
    pub fn language_code(mut self, new_value: &str) -> ProjectAgentEntityTypeGetCall<'a, C, A> {
        self._language_code = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypeGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypeGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypeGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all documents of the knowledge base.
///
/// A builder for the *knowledgeBases.documents.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().knowledge_bases_documents_list("parent")
///              .page_token("sadipscing")
///              .page_size(-48)
///              .doit();
/// # }
/// ```
pub struct ProjectKnowledgeBaseDocumentListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectKnowledgeBaseDocumentListCall<'a, C, A> {}

impl<'a, C, A> ProjectKnowledgeBaseDocumentListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListDocumentsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.knowledgeBases.documents.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/documents";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The knowledge base to list all documents for.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectKnowledgeBaseDocumentListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectKnowledgeBaseDocumentListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 10 and at most 100.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectKnowledgeBaseDocumentListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectKnowledgeBaseDocumentListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectKnowledgeBaseDocumentListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectKnowledgeBaseDocumentListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified document.
/// 
/// Operation <response: google.protobuf.Empty,
///            metadata: KnowledgeOperationMetadata>
///
/// A builder for the *knowledgeBases.documents.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().knowledge_bases_documents_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectKnowledgeBaseDocumentDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectKnowledgeBaseDocumentDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectKnowledgeBaseDocumentDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.knowledgeBases.documents.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// The name of the document to delete.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
    /// ID>/documents/<Document ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectKnowledgeBaseDocumentDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectKnowledgeBaseDocumentDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectKnowledgeBaseDocumentDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectKnowledgeBaseDocumentDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of agents.
/// 
/// Since there is at most one conversational agent per project, this method is
/// useful primarily for listing all agents across projects the caller has
/// access to. One can achieve that with a wildcard project collection id "-".
/// Refer to [List
/// Sub-Collections](https://cloud.google.com/apis/design/design_patterns#list_sub-collections).
///
/// A builder for the *agent.search* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_search("parent")
///              .page_token("amet")
///              .page_size(-60)
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSearchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSearchCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSearchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1SearchAgentsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.search",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/agent:search";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The project to list agents from.
    /// Format: `projects/<Project ID or '-'>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentSearchCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectAgentSearchCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectAgentSearchCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSearchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSearchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSearchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified intent.
///
/// A builder for the *agent.intents.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Intent;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Intent::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_intents_patch(req, "name")
///              .update_mask("eirmod")
///              .language_code("dolore")
///              .intent_view("invidunt")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentIntentPatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Intent,
    _name: String,
    _update_mask: Option<String>,
    _language_code: Option<String>,
    _intent_view: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentIntentPatchCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentIntentPatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Intent), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.intents.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(7 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        if let Some(value) = self._language_code {
            params.push(("languageCode", value.to_string()));
        }
        if let Some(value) = self._intent_view {
            params.push(("intentView", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask", "languageCode", "intentView"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Intent) -> ProjectAgentIntentPatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required for all methods except `create` (`create` populates the name
    /// automatically.
    /// The unique identifier of this intent.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentIntentPatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to control which fields get updated.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectAgentIntentPatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// Optional. The language of training phrases, parameters and rich messages
    /// defined in `intent`. If not specified, the agent's default language is
    /// used. [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    ///
    /// Sets the *language code* query property to the given value.
    pub fn language_code(mut self, new_value: &str) -> ProjectAgentIntentPatchCall<'a, C, A> {
        self._language_code = Some(new_value.to_string());
        self
    }
    /// Optional. The resource view to apply to the returned intent.
    ///
    /// Sets the *intent view* query property to the given value.
    pub fn intent_view(mut self, new_value: &str) -> ProjectAgentIntentPatchCall<'a, C, A> {
        self._intent_view = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentIntentPatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentIntentPatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentIntentPatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified human agent assistant.
///
/// A builder for the *humanAgentAssistants.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().human_agent_assistants_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectHumanAgentAssistantDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectHumanAgentAssistantDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectHumanAgentAssistantDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.humanAgentAssistants.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The resource name of the agent assistant.
    /// Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    /// ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectHumanAgentAssistantDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectHumanAgentAssistantDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectHumanAgentAssistantDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectHumanAgentAssistantDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes all active contexts in the specified session.
///
/// A builder for the *agent.environments.users.sessions.deleteContexts* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_delete_contexts("parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionDeleteContextCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionDeleteContextCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionDeleteContextCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.deleteContexts",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/contexts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the session to delete all contexts from. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>` or `projects/<Project
    /// ID>/agent/environments/<Environment ID>/users/<User ID>/sessions/<Session
    /// ID>`. If `Environment ID` is not specified we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionDeleteContextCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionDeleteContextCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionDeleteContextCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionDeleteContextCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified `PhoneNumber`.
///
/// A builder for the *phoneNumbers.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1PhoneNumber;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1PhoneNumber::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().phone_numbers_patch(req, "name")
///              .update_mask("sea")
///              .doit();
/// # }
/// ```
pub struct ProjectPhoneNumberPatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1PhoneNumber,
    _name: String,
    _update_mask: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectPhoneNumberPatchCall<'a, C, A> {}

impl<'a, C, A> ProjectPhoneNumberPatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1PhoneNumber), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.phoneNumbers.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1PhoneNumber) -> ProjectPhoneNumberPatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The unique identifier of this phone number.
    /// Format: `projects/<Project ID>/phoneNumbers/<PhoneNumber ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectPhoneNumberPatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to control which fields get updated.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectPhoneNumberPatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectPhoneNumberPatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectPhoneNumberPatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectPhoneNumberPatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all knowledge bases of the specified agent.
///
/// A builder for the *knowledgeBases.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().knowledge_bases_list("parent")
///              .page_token("duo")
///              .page_size(-21)
///              .doit();
/// # }
/// ```
pub struct ProjectKnowledgeBaseListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectKnowledgeBaseListCall<'a, C, A> {}

impl<'a, C, A> ProjectKnowledgeBaseListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListKnowledgeBasesResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.knowledgeBases.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/knowledgeBases";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The project to list of knowledge bases for.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectKnowledgeBaseListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectKnowledgeBaseListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 10 and at most 100.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectKnowledgeBaseListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectKnowledgeBaseListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectKnowledgeBaseListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectKnowledgeBaseListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes all active contexts in the specified session.
///
/// A builder for the *agent.sessions.deleteContexts* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_delete_contexts("parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionDeleteContextCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionDeleteContextCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionDeleteContextCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.deleteContexts",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/contexts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the session to delete all contexts from. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>` or `projects/<Project
    /// ID>/agent/environments/<Environment ID>/users/<User ID>/sessions/<Session
    /// ID>`. If `Environment ID` is not specified we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentSessionDeleteContextCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionDeleteContextCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionDeleteContextCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionDeleteContextCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified document.
/// 
/// Operation <response: google.protobuf.Empty,
///            metadata: KnowledgeOperationMetadata>
///
/// A builder for the *agent.knowledgeBases.documents.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_knowledge_bases_documents_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentKnowledgeBaseDocumentDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentKnowledgeBaseDocumentDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentKnowledgeBaseDocumentDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.knowledgeBases.documents.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// The name of the document to delete.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
    /// ID>/documents/<Document ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseDocumentDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentKnowledgeBaseDocumentDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentKnowledgeBaseDocumentDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentKnowledgeBaseDocumentDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes entity types in the specified agent.
/// 
/// Operation <response: google.protobuf.Empty,
///            metadata: google.protobuf.Struct>
///
/// A builder for the *agent.entityTypes.batchDelete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1BatchDeleteEntityTypesRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1BatchDeleteEntityTypesRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_batch_delete(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypeBatchDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1BatchDeleteEntityTypesRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypeBatchDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypeBatchDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.batchDelete",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entityTypes:batchDelete";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1BatchDeleteEntityTypesRequest) -> ProjectAgentEntityTypeBatchDeleteCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the agent to delete all entities types for. Format:
    /// `projects/<Project ID>/agent`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEntityTypeBatchDeleteCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypeBatchDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypeBatchDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypeBatchDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Imports the specified agent from a ZIP file.
/// 
/// Uploads new intents and entity types without deleting the existing ones.
/// Intents and entity types with the same name are replaced with the new
/// versions from ImportAgentRequest.
/// 
/// 
/// Operation <response: google.protobuf.Empty,
///            metadata: google.protobuf.Struct>
///
/// A builder for the *agent.import* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1ImportAgentRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1ImportAgentRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_import(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentImportCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1ImportAgentRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentImportCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentImportCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.import",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/agent:import";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1ImportAgentRequest) -> ProjectAgentImportCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The project that the agent to import is associated with.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentImportCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentImportCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentImportCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentImportCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a context.
/// 
/// If the specified context already exists, overrides the context.
///
/// A builder for the *environments.users.conversations.contexts.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Context;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Context::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().environments_users_conversations_contexts_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectEnvironmentUserConversationContextCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Context,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectEnvironmentUserConversationContextCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectEnvironmentUserConversationContextCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Context), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.environments.users.conversations.contexts.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/contexts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Context) -> ProjectEnvironmentUserConversationContextCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The session to create a context for.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we assume
    /// default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectEnvironmentUserConversationContextCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectEnvironmentUserConversationContextCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectEnvironmentUserConversationContextCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectEnvironmentUserConversationContextCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified context.
///
/// A builder for the *environments.users.conversations.contexts.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Context;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Context::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().environments_users_conversations_contexts_patch(req, "name")
///              .update_mask("ut")
///              .doit();
/// # }
/// ```
pub struct ProjectEnvironmentUserConversationContextPatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Context,
    _name: String,
    _update_mask: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectEnvironmentUserConversationContextPatchCall<'a, C, A> {}

impl<'a, C, A> ProjectEnvironmentUserConversationContextPatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Context), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.environments.users.conversations.contexts.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Context) -> ProjectEnvironmentUserConversationContextPatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The unique identifier of the context. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`,
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. The `Context ID` is
    /// always converted to lowercase. If `Environment ID` is not specified, we
    /// assume default 'draft' environment. If `User ID` is not specified, we
    /// assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectEnvironmentUserConversationContextPatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to control which fields get updated.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectEnvironmentUserConversationContextPatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectEnvironmentUserConversationContextPatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectEnvironmentUserConversationContextPatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectEnvironmentUserConversationContextPatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all knowledge bases of the specified agent.
///
/// A builder for the *agent.knowledgeBases.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_knowledge_bases_list("parent")
///              .page_token("sed")
///              .page_size(-3)
///              .doit();
/// # }
/// ```
pub struct ProjectAgentKnowledgeBaseListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentKnowledgeBaseListCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentKnowledgeBaseListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListKnowledgeBasesResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.knowledgeBases.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/knowledgeBases";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The project to list of knowledge bases for.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 10 and at most 100.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectAgentKnowledgeBaseListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentKnowledgeBaseListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentKnowledgeBaseListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentKnowledgeBaseListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates or creates multiple entities in the specified entity type. This
/// method does not affect entities in the entity type that aren't explicitly
/// specified in the request.
/// 
/// Operation <response: google.protobuf.Empty,
///            metadata: google.protobuf.Struct>
///
/// A builder for the *agent.entityTypes.entities.batchUpdate* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1BatchUpdateEntitiesRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1BatchUpdateEntitiesRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_entities_batch_update(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypeEntityBatchUpdateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1BatchUpdateEntitiesRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypeEntityBatchUpdateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypeEntityBatchUpdateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.entities.batchUpdate",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entities:batchUpdate";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1BatchUpdateEntitiesRequest) -> ProjectAgentEntityTypeEntityBatchUpdateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the entity type to update or create entities in.
    /// Format: `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEntityTypeEntityBatchUpdateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypeEntityBatchUpdateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypeEntityBatchUpdateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypeEntityBatchUpdateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a context.
/// 
/// If the specified context already exists, overrides the context.
///
/// A builder for the *agent.sessions.contexts.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Context;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Context::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_contexts_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionContextCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Context,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionContextCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionContextCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Context), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.contexts.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/contexts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Context) -> ProjectAgentSessionContextCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The session to create a context for.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we assume
    /// default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentSessionContextCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionContextCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionContextCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionContextCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all session entity types in the specified session.
///
/// A builder for the *agent.sessions.entityTypes.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_entity_types_list("parent")
///              .page_token("consetetur")
///              .page_size(-52)
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionEntityTypeListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionEntityTypeListCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionEntityTypeListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListSessionEntityTypesResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.entityTypes.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entityTypes";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The session to list all session entity types from.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    /// sessions/<Session ID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentSessionEntityTypeListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectAgentSessionEntityTypeListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectAgentSessionEntityTypeListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionEntityTypeListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionEntityTypeListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionEntityTypeListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Cancels an `PhoneNumberOrder`.
/// Returns an error if the order is in state
/// IN_PROGRESS or
/// COMPLETED.
///
/// A builder for the *phoneNumberOrders.cancel* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1CancelPhoneNumberOrderRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1CancelPhoneNumberOrderRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().phone_number_orders_cancel(req, "name")
///              .doit();
/// # }
/// ```
pub struct ProjectPhoneNumberOrderCancelCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1CancelPhoneNumberOrderRequest,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectPhoneNumberOrderCancelCall<'a, C, A> {}

impl<'a, C, A> ProjectPhoneNumberOrderCancelCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.phoneNumberOrders.cancel",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}:cancel";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1CancelPhoneNumberOrderRequest) -> ProjectPhoneNumberOrderCancelCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The unique identifier of the order to delete.
    /// Format: `projects/<Project ID>/phoneNumberOrders/<Order ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectPhoneNumberOrderCancelCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectPhoneNumberOrderCancelCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectPhoneNumberOrderCancelCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectPhoneNumberOrderCancelCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified knowledge base.
///
/// A builder for the *knowledgeBases.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().knowledge_bases_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectKnowledgeBaseGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectKnowledgeBaseGetCall<'a, C, A> {}

impl<'a, C, A> ProjectKnowledgeBaseGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1KnowledgeBase), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.knowledgeBases.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the knowledge base to retrieve.
    /// Format `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectKnowledgeBaseGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectKnowledgeBaseGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectKnowledgeBaseGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectKnowledgeBaseGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified human agent assistant.
///
/// A builder for the *humanAgentAssistants.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1HumanAgentAssistant;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1HumanAgentAssistant::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().human_agent_assistants_patch(req, "name")
///              .update_mask("justo")
///              .doit();
/// # }
/// ```
pub struct ProjectHumanAgentAssistantPatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1HumanAgentAssistant,
    _name: String,
    _update_mask: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectHumanAgentAssistantPatchCall<'a, C, A> {}

impl<'a, C, A> ProjectHumanAgentAssistantPatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1HumanAgentAssistant), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.humanAgentAssistants.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1HumanAgentAssistant) -> ProjectHumanAgentAssistantPatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required for all methods except `create` (`create` populates the name
    /// automatically).
    /// The unique identifier of human agent assistant.
    /// Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    /// ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectHumanAgentAssistantPatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to specify which fields to update.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectHumanAgentAssistantPatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectHumanAgentAssistantPatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectHumanAgentAssistantPatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectHumanAgentAssistantPatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Processes a natural language query and returns structured, actionable data
/// as a result. This method is not idempotent, because it may cause contexts
/// and session entity types to be updated, which in turn might affect
/// results of future queries.
///
/// A builder for the *agent.environments.users.sessions.detectIntent* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1DetectIntentRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1DetectIntentRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_detect_intent(req, "session")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionDetectIntentCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1DetectIntentRequest,
    _session: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionDetectIntentCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionDetectIntentCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1DetectIntentResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.detectIntent",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("session", self._session.to_string()));
        for &field in ["alt", "session"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+session}:detectIntent";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+session}", "session")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["session"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1DetectIntentRequest) -> ProjectAgentEnvironmentUserSessionDetectIntentCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the session this query is sent to. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>`, or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we are using
    /// "-". It’s up to the API caller to choose an appropriate `Session ID` and
    /// `User Id`. They can be a random numbers or some type of user and session
    /// identifiers (preferably hashed). The length of the `Session ID` and
    /// `User ID` must not exceed 36 characters.
    ///
    /// Sets the *session* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn session(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionDetectIntentCall<'a, C, A> {
        self._session = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionDetectIntentCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionDetectIntentCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionDetectIntentCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Requests deletion of a `PhoneNumber`. The `PhoneNumber` is moved into the
/// DELETE_REQUESTED state
/// immediately, and is deleted approximately 30 days later. This method may
/// only be called on a `PhoneNumber` in the
/// ACTIVE state.
///
/// A builder for the *phoneNumbers.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().phone_numbers_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectPhoneNumberDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectPhoneNumberDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectPhoneNumberDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1PhoneNumber), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.phoneNumbers.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The unique identifier of the `PhoneNumber` to delete.
    /// Format: `projects/<Project ID>/phoneNumbers/<PhoneNumber ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectPhoneNumberDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectPhoneNumberDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectPhoneNumberDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectPhoneNumberDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified entity type.
///
/// A builder for the *agent.entityTypes.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypeDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypeDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypeDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the entity type to delete.
    /// Format: `projects/<Project ID>/agent/entityTypes/<EntityType ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentEntityTypeDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypeDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypeDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypeDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified context.
///
/// A builder for the *agent.sessions.contexts.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Context;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Context::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_contexts_patch(req, "name")
///              .update_mask("consetetur")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionContextPatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Context,
    _name: String,
    _update_mask: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionContextPatchCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionContextPatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Context), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.contexts.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Context) -> ProjectAgentSessionContextPatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The unique identifier of the context. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`,
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. The `Context ID` is
    /// always converted to lowercase. If `Environment ID` is not specified, we
    /// assume default 'draft' environment. If `User ID` is not specified, we
    /// assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentSessionContextPatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to control which fields get updated.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectAgentSessionContextPatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionContextPatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionContextPatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionContextPatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified context.
///
/// A builder for the *agent.sessions.contexts.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_contexts_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionContextGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionContextGetCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionContextGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Context), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.contexts.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the context. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    /// not specified, we assume default 'draft' environment. If `User ID` is not
    /// specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentSessionContextGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionContextGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionContextGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionContextGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves a conversation participant.
///
/// A builder for the *conversations.participants.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_participants_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationParticipantGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationParticipantGetCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationParticipantGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Participant), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.participants.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the participant. Format:
    /// `projects/<Project ID>/conversations/<Conversation
    /// ID>/participants/<Participant ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectConversationParticipantGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationParticipantGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationParticipantGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationParticipantGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Trains the specified agent.
/// 
/// 
/// Operation <response: google.protobuf.Empty,
///            metadata: google.protobuf.Struct>
///
/// A builder for the *agent.train* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1TrainAgentRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1TrainAgentRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_train(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentTrainCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1TrainAgentRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentTrainCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentTrainCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.train",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/agent:train";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1TrainAgentRequest) -> ProjectAgentTrainCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The project that the agent to train is associated with.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentTrainCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentTrainCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentTrainCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentTrainCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified context.
///
/// A builder for the *agent.sessions.contexts.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_contexts_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionContextDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionContextDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionContextDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.contexts.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the context to delete. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    /// not specified, we assume default 'draft' environment. If `User ID` is not
    /// specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentSessionContextDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionContextDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionContextDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionContextDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all contexts in the specified session.
///
/// A builder for the *environments.users.conversations.contexts.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().environments_users_conversations_contexts_list("parent")
///              .page_token("dolore")
///              .page_size(-19)
///              .doit();
/// # }
/// ```
pub struct ProjectEnvironmentUserConversationContextListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectEnvironmentUserConversationContextListCall<'a, C, A> {}

impl<'a, C, A> ProjectEnvironmentUserConversationContextListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListContextsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.environments.users.conversations.contexts.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/contexts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The session to list all contexts from.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we assume
    /// default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectEnvironmentUserConversationContextListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectEnvironmentUserConversationContextListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectEnvironmentUserConversationContextListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectEnvironmentUserConversationContextListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectEnvironmentUserConversationContextListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectEnvironmentUserConversationContextListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified context.
///
/// A builder for the *environments.users.conversations.contexts.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().environments_users_conversations_contexts_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectEnvironmentUserConversationContextGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectEnvironmentUserConversationContextGetCall<'a, C, A> {}

impl<'a, C, A> ProjectEnvironmentUserConversationContextGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Context), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.environments.users.conversations.contexts.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the context. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    /// not specified, we assume default 'draft' environment. If `User ID` is not
    /// specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectEnvironmentUserConversationContextGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectEnvironmentUserConversationContextGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectEnvironmentUserConversationContextGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectEnvironmentUserConversationContextGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all participants in the specified conversation.
///
/// A builder for the *conversations.participants.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_participants_list("parent")
///              .page_token("et")
///              .page_size(-13)
///              .doit();
/// # }
/// ```
pub struct ProjectConversationParticipantListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationParticipantListCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationParticipantListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListParticipantsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.participants.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/participants";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The conversation to list all contexts from.
    /// Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectConversationParticipantListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectConversationParticipantListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectConversationParticipantListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationParticipantListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationParticipantListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationParticipantListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified context.
///
/// A builder for the *agent.environments.users.sessions.contexts.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_contexts_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionContextDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionContextDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionContextDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.contexts.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the context to delete. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`. If `Environment ID` is
    /// not specified, we assume default 'draft' environment. If `User ID` is not
    /// specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionContextDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionContextDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionContextDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionContextDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified session entity type.
///
/// A builder for the *agent.environments.users.sessions.entityTypes.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_entity_types_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.entityTypes.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the entity type to delete. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    /// ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    /// Name>`. If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionEntityTypeDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates an order to request phone numbers be added to a project.
/// The initial `LifecycleState` of a newly created order is
/// PENDING.
///
/// A builder for the *phoneNumberOrders.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1PhoneNumberOrder;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1PhoneNumberOrder::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().phone_number_orders_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectPhoneNumberOrderCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1PhoneNumberOrder,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectPhoneNumberOrderCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectPhoneNumberOrderCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1PhoneNumberOrder), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.phoneNumberOrders.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/phoneNumberOrders";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1PhoneNumberOrder) -> ProjectPhoneNumberOrderCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. Resource identifier of the project requesting the orders.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectPhoneNumberOrderCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectPhoneNumberOrderCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectPhoneNumberOrderCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectPhoneNumberOrderCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Lists of all `PhoneNumberOrder` resources in the specified project.
///
/// A builder for the *phoneNumberOrders.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().phone_number_orders_list("parent")
///              .page_token("sanctus")
///              .page_size(-58)
///              .doit();
/// # }
/// ```
pub struct ProjectPhoneNumberOrderListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectPhoneNumberOrderListCall<'a, C, A> {}

impl<'a, C, A> ProjectPhoneNumberOrderListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListPhoneNumberOrdersResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.phoneNumberOrders.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/phoneNumberOrders";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The project to list all orders from.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectPhoneNumberOrderListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectPhoneNumberOrderListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page.
    /// The default value is 100. The maximum value is 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectPhoneNumberOrderListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectPhoneNumberOrderListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectPhoneNumberOrderListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectPhoneNumberOrderListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Processes a natural language query and returns structured, actionable data
/// as a result. This method is not idempotent, because it may cause contexts
/// and session entity types to be updated, which in turn might affect
/// results of future queries.
///
/// A builder for the *agent.sessions.detectIntent* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1DetectIntentRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1DetectIntentRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_detect_intent(req, "session")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionDetectIntentCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1DetectIntentRequest,
    _session: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionDetectIntentCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionDetectIntentCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1DetectIntentResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.detectIntent",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("session", self._session.to_string()));
        for &field in ["alt", "session"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+session}:detectIntent";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+session}", "session")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["session"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1DetectIntentRequest) -> ProjectAgentSessionDetectIntentCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the session this query is sent to. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>`, or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we are using
    /// "-". It’s up to the API caller to choose an appropriate `Session ID` and
    /// `User Id`. They can be a random numbers or some type of user and session
    /// identifiers (preferably hashed). The length of the `Session ID` and
    /// `User ID` must not exceed 36 characters.
    ///
    /// Sets the *session* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn session(mut self, new_value: &str) -> ProjectAgentSessionDetectIntentCall<'a, C, A> {
        self._session = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionDetectIntentCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionDetectIntentCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionDetectIntentCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a new document.
/// 
/// Operation <response: Document,
///            metadata: KnowledgeOperationMetadata>
///
/// A builder for the *knowledgeBases.documents.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Document;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Document::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().knowledge_bases_documents_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectKnowledgeBaseDocumentCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Document,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectKnowledgeBaseDocumentCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectKnowledgeBaseDocumentCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.knowledgeBases.documents.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/documents";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Document) -> ProjectKnowledgeBaseDocumentCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The knoweldge base to create a document for.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectKnowledgeBaseDocumentCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectKnowledgeBaseDocumentCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectKnowledgeBaseDocumentCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectKnowledgeBaseDocumentCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specific conversation.
///
/// A builder for the *conversations.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationGetCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Conversation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the conversation. Format:
    /// `projects/<Project ID>/conversations/<Conversation ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectConversationGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified knowledge base.
///
/// A builder for the *knowledgeBases.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().knowledge_bases_delete("name")
///              .force(false)
///              .doit();
/// # }
/// ```
pub struct ProjectKnowledgeBaseDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _force: Option<bool>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectKnowledgeBaseDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectKnowledgeBaseDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.knowledgeBases.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._force {
            params.push(("force", value.to_string()));
        }
        for &field in ["alt", "name", "force"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the knowledge base to delete.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectKnowledgeBaseDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. Force deletes the knowledge base. When set to true, any documents
    /// in the knowledge base are also deleted.
    ///
    /// Sets the *force* query property to the given value.
    pub fn force(mut self, new_value: bool) -> ProjectKnowledgeBaseDeleteCall<'a, C, A> {
        self._force = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectKnowledgeBaseDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectKnowledgeBaseDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectKnowledgeBaseDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified `PhoneNumberOrder` resource.
/// Returns an error if the order is in state
/// IN_PROGRESS or
/// COMPLETED.
///
/// A builder for the *phoneNumberOrders.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1PhoneNumberOrder;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1PhoneNumberOrder::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().phone_number_orders_patch(req, "name")
///              .update_mask("dolore")
///              .doit();
/// # }
/// ```
pub struct ProjectPhoneNumberOrderPatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1PhoneNumberOrder,
    _name: String,
    _update_mask: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectPhoneNumberOrderPatchCall<'a, C, A> {}

impl<'a, C, A> ProjectPhoneNumberOrderPatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1PhoneNumberOrder), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.phoneNumberOrders.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1PhoneNumberOrder) -> ProjectPhoneNumberOrderPatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The unique identifier of this order.
    /// Format: `projects/<Project ID>/phoneNumberOrders/<Order ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectPhoneNumberOrderPatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to control which fields get updated.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectPhoneNumberOrderPatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectPhoneNumberOrderPatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectPhoneNumberOrderPatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectPhoneNumberOrderPatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes all active contexts in the specified session.
///
/// A builder for the *environments.users.conversations.deleteContexts* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().environments_users_conversations_delete_contexts("parent")
///              .doit();
/// # }
/// ```
pub struct ProjectEnvironmentUserConversationDeleteContextCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectEnvironmentUserConversationDeleteContextCall<'a, C, A> {}

impl<'a, C, A> ProjectEnvironmentUserConversationDeleteContextCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.environments.users.conversations.deleteContexts",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/contexts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the session to delete all contexts from. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>` or `projects/<Project
    /// ID>/agent/environments/<Environment ID>/users/<User ID>/sessions/<Session
    /// ID>`. If `Environment ID` is not specified we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectEnvironmentUserConversationDeleteContextCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectEnvironmentUserConversationDeleteContextCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectEnvironmentUserConversationDeleteContextCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectEnvironmentUserConversationDeleteContextCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Gets the latest state of a long-running operation.  Clients can use this
/// method to poll the operation result at intervals as recommended by the API
/// service.
///
/// A builder for the *operations.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().operations_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectOperationGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectOperationGetCall<'a, C, A> {}

impl<'a, C, A> ProjectOperationGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.operations.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// The name of the operation resource.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectOperationGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectOperationGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectOperationGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectOperationGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a new participant in a conversation.
///
/// A builder for the *conversations.participants.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Participant;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Participant::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_participants_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationParticipantCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Participant,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationParticipantCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationParticipantCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Participant), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.participants.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/participants";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Participant) -> ProjectConversationParticipantCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. Resource identifier of the conversation adding the participant.
    /// Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectConversationParticipantCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationParticipantCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationParticipantCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationParticipantCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Sets a phone number for this converstion to connect to.
///
/// A builder for the *conversations.addConversationPhoneNumber* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1AddConversationPhoneNumberRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1AddConversationPhoneNumberRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_add_conversation_phone_number(req, "name")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationAddConversationPhoneNumberCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1AddConversationPhoneNumberRequest,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationAddConversationPhoneNumberCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationAddConversationPhoneNumberCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ConversationPhoneNumber), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.addConversationPhoneNumber",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}:addConversationPhoneNumber";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1AddConversationPhoneNumberRequest) -> ProjectConversationAddConversationPhoneNumberCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The name of this conversation.
    /// Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectConversationAddConversationPhoneNumberCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationAddConversationPhoneNumberCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationAddConversationPhoneNumberCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationAddConversationPhoneNumberCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all conversation profiles in the specified project.
///
/// A builder for the *conversationProfiles.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversation_profiles_list("parent")
///              .page_token("consetetur")
///              .page_size(-85)
///              .doit();
/// # }
/// ```
pub struct ProjectConversationProfileListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationProfileListCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationProfileListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListConversationProfilesResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversationProfiles.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/conversationProfiles";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The project to list all conversation profiles from.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectConversationProfileListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectConversationProfileListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectConversationProfileListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationProfileListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationProfileListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationProfileListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a session entity type.
/// 
/// If the specified session entity type already exists, overrides the
/// session entity type.
///
/// A builder for the *agent.environments.users.sessions.entityTypes.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1SessionEntityType;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1SessionEntityType::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_entity_types_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionEntityTypeCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1SessionEntityType,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionEntityTypeCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionEntityTypeCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1SessionEntityType), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.entityTypes.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entityTypes";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1SessionEntityType) -> ProjectAgentEnvironmentUserSessionEntityTypeCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The session to create a session entity type for.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    /// sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we assume
    /// default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionEntityTypeCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionEntityTypeCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionEntityTypeCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionEntityTypeCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a context.
/// 
/// If the specified context already exists, overrides the context.
///
/// A builder for the *agent.environments.users.sessions.contexts.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Context;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Context::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_environments_users_sessions_contexts_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEnvironmentUserSessionContextCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Context,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEnvironmentUserSessionContextCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEnvironmentUserSessionContextCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Context), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.environments.users.sessions.contexts.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/contexts";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Context) -> ProjectAgentEnvironmentUserSessionContextCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The session to create a context for.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we assume
    /// default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEnvironmentUserSessionContextCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEnvironmentUserSessionContextCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEnvironmentUserSessionContextCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEnvironmentUserSessionContextCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates an entity type in the specified agent.
///
/// A builder for the *agent.entityTypes.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1EntityType;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1EntityType::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_create(req, "parent")
///              .language_code("aliquyam")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypeCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1EntityType,
    _parent: String,
    _language_code: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypeCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypeCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1EntityType), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._language_code {
            params.push(("languageCode", value.to_string()));
        }
        for &field in ["alt", "parent", "languageCode"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entityTypes";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1EntityType) -> ProjectAgentEntityTypeCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The agent to create a entity type for.
    /// Format: `projects/<Project ID>/agent`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEntityTypeCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The language of entity synonyms defined in `entity_type`. If not
    /// specified, the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    ///
    /// Sets the *language code* query property to the given value.
    pub fn language_code(mut self, new_value: &str) -> ProjectAgentEntityTypeCreateCall<'a, C, A> {
        self._language_code = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypeCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypeCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypeCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Adds a text (chat, for example), or audio (phone recording, for example)
/// message from a participan  into the conversation.
/// Note: This method is only available through the gRPC API (not REST).
/// 
/// The top-level message sent to the client by the server is
/// `StreamingAnalyzeContentResponse`. Multiple response messages can be
/// returned in order. The first one or more messages contain the
/// `recognition_result` field. Each result represents a more complete
/// transcript of what the user said. The next message contains the
/// `reply_text` field and potentially the `reply_audio` field. The message can
/// also contain the `automated_agent_reply` field.
///
/// A builder for the *conversations.participants.streamingAnalyzeContent* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1StreamingAnalyzeContentRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1StreamingAnalyzeContentRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_participants_streaming_analyze_content(req, "participant")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationParticipantStreamingAnalyzeContentCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1StreamingAnalyzeContentRequest,
    _participant: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationParticipantStreamingAnalyzeContentCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationParticipantStreamingAnalyzeContentCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1StreamingAnalyzeContentResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.participants.streamingAnalyzeContent",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("participant", self._participant.to_string()));
        for &field in ["alt", "participant"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+participant}:streamingAnalyzeContent";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+participant}", "participant")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["participant"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1StreamingAnalyzeContentRequest) -> ProjectConversationParticipantStreamingAnalyzeContentCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the participant this text comes from.
    /// Format: `projects/<Project ID>/conversations/<Conversation
    /// ID>/participants/<Participant ID>`.
    ///
    /// Sets the *participant* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn participant(mut self, new_value: &str) -> ProjectConversationParticipantStreamingAnalyzeContentCall<'a, C, A> {
        self._participant = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationParticipantStreamingAnalyzeContentCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationParticipantStreamingAnalyzeContentCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationParticipantStreamingAnalyzeContentCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes entities in the specified entity type.
/// 
/// Operation <response: google.protobuf.Empty,
///            metadata: google.protobuf.Struct>
///
/// A builder for the *agent.entityTypes.entities.batchDelete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1BatchDeleteEntitiesRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1BatchDeleteEntitiesRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_entities_batch_delete(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypeEntityBatchDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1BatchDeleteEntitiesRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypeEntityBatchDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypeEntityBatchDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.entities.batchDelete",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entities:batchDelete";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1BatchDeleteEntitiesRequest) -> ProjectAgentEntityTypeEntityBatchDeleteCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the entity type to delete entries for. Format:
    /// `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEntityTypeEntityBatchDeleteCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypeEntityBatchDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypeEntityBatchDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypeEntityBatchDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a new document.
/// 
/// Operation <response: Document,
///            metadata: KnowledgeOperationMetadata>
///
/// A builder for the *agent.knowledgeBases.documents.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Document;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Document::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_knowledge_bases_documents_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentKnowledgeBaseDocumentCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Document,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentKnowledgeBaseDocumentCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentKnowledgeBaseDocumentCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.knowledgeBases.documents.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/documents";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Document) -> ProjectAgentKnowledgeBaseDocumentCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The knoweldge base to create a document for.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseDocumentCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentKnowledgeBaseDocumentCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentKnowledgeBaseDocumentCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentKnowledgeBaseDocumentCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified entity type.
///
/// A builder for the *agent.entityTypes.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1EntityType;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1EntityType::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_patch(req, "name")
///              .update_mask("ipsum")
///              .language_code("aliquyam")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypePatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1EntityType,
    _name: String,
    _update_mask: Option<String>,
    _language_code: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypePatchCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypePatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1EntityType), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        if let Some(value) = self._language_code {
            params.push(("languageCode", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask", "languageCode"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1EntityType) -> ProjectAgentEntityTypePatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required for all methods except `create` (`create` populates the name
    /// automatically.
    /// The unique identifier of the entity type. Format:
    /// `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentEntityTypePatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to control which fields get updated.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectAgentEntityTypePatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// Optional. The language of entity synonyms defined in `entity_type`. If not
    /// specified, the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    ///
    /// Sets the *language code* query property to the given value.
    pub fn language_code(mut self, new_value: &str) -> ProjectAgentEntityTypePatchCall<'a, C, A> {
        self._language_code = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypePatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypePatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypePatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves suggestions for live agents.
/// 
/// This method should be used by human agent client software to fetch
/// suggestions in real-time, while the conversation with an end user is in
/// progress. The functionality is implemented in terms of the
/// [list pagination](/apis/design/design_patterns#list_pagination)
/// design pattern. The client app should use the `next_page_token` field
/// to fetch the next batch of suggestions.
///
/// A builder for the *conversations.participants.suggestions.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_participants_suggestions_list("parent")
///              .page_token("sit")
///              .page_size(-41)
///              .doit();
/// # }
/// ```
pub struct ProjectConversationParticipantSuggestionListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationParticipantSuggestionListCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationParticipantSuggestionListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListSuggestionsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.participants.suggestions.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/suggestions";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the conversation participant for whom to fetch
    /// suggestions.
    /// Format: `projects/<Project ID>/conversations/<Conversation
    /// ID>/participants/<Participant ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectConversationParticipantSuggestionListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectConversationParticipantSuggestionListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. The
    /// default value is 100; the maximum value is 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectConversationParticipantSuggestionListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationParticipantSuggestionListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationParticipantSuggestionListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationParticipantSuggestionListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified agent.
///
/// A builder for the *getAgent* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().get_agent("parent")
///              .doit();
/// # }
/// ```
pub struct ProjectGetAgentCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectGetAgentCall<'a, C, A> {}

impl<'a, C, A> ProjectGetAgentCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Agent), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.getAgent",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/agent";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The project that the agent to fetch is associated with.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectGetAgentCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectGetAgentCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectGetAgentCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectGetAgentCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a knowledge base.
///
/// A builder for the *knowledgeBases.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1KnowledgeBase;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1KnowledgeBase::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().knowledge_bases_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectKnowledgeBaseCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1KnowledgeBase,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectKnowledgeBaseCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectKnowledgeBaseCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1KnowledgeBase), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.knowledgeBases.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/knowledgeBases";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1KnowledgeBase) -> ProjectKnowledgeBaseCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The project to create a knowledge base for.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectKnowledgeBaseCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectKnowledgeBaseCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectKnowledgeBaseCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectKnowledgeBaseCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all documents of the knowledge base.
///
/// A builder for the *agent.knowledgeBases.documents.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_knowledge_bases_documents_list("parent")
///              .page_token("amet")
///              .page_size(-23)
///              .doit();
/// # }
/// ```
pub struct ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListDocumentsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.knowledgeBases.documents.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/documents";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The knowledge base to list all documents for.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 10 and at most 100.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentKnowledgeBaseDocumentListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Completes the specified conversation. Finished conversations are purged
/// from the database after 30 days.
///
/// A builder for the *conversations.complete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1CompleteConversationRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1CompleteConversationRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_complete(req, "name")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationCompleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1CompleteConversationRequest,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationCompleteCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationCompleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Conversation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.complete",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}:complete";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1CompleteConversationRequest) -> ProjectConversationCompleteCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. Resource identifier of the conversation to close.
    /// Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectConversationCompleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationCompleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationCompleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationCompleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified intent and its direct or indirect followup intents.
///
/// A builder for the *agent.intents.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_intents_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentIntentDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentIntentDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentIntentDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.intents.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the intent to delete. If this intent has direct or
    /// indirect followup intents, we also delete them.
    /// 
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentIntentDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentIntentDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentIntentDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentIntentDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Lists messages that belong to a given conversation.
///
/// A builder for the *conversations.messages.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_messages_list("parent")
///              .page_token("est")
///              .page_size(-63)
///              .doit();
/// # }
/// ```
pub struct ProjectConversationMessageListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationMessageListCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationMessageListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListMessagesResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.messages.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/messages";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the conversation to list messages for.
    /// Format: `projects/<Project ID>/conversations/<Conversation ID>`
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectConversationMessageListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectConversationMessageListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectConversationMessageListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationMessageListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationMessageListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationMessageListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified knowledge base.
///
/// A builder for the *agent.knowledgeBases.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_knowledge_bases_delete("name")
///              .force(false)
///              .doit();
/// # }
/// ```
pub struct ProjectAgentKnowledgeBaseDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _force: Option<bool>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentKnowledgeBaseDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentKnowledgeBaseDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.knowledgeBases.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._force {
            params.push(("force", value.to_string()));
        }
        for &field in ["alt", "name", "force"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the knowledge base to delete.
    /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. Force deletes the knowledge base. When set to true, any documents
    /// in the knowledge base are also deleted.
    ///
    /// Sets the *force* query property to the given value.
    pub fn force(mut self, new_value: bool) -> ProjectAgentKnowledgeBaseDeleteCall<'a, C, A> {
        self._force = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentKnowledgeBaseDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentKnowledgeBaseDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentKnowledgeBaseDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified conversation profile.
///
/// A builder for the *conversationProfiles.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversation_profiles_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationProfileGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationProfileGetCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationProfileGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ConversationProfile), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversationProfiles.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The resource name of the conversation profile.
    /// Format: `projects/<Project ID>/conversationProfiles/<Conversation Profile
    /// ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectConversationProfileGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationProfileGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationProfileGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationProfileGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a new conversation. Conversation are auto-completed after 24 hours.
///
/// A builder for the *conversations.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Conversation;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Conversation::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Conversation,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Conversation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/conversations";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Conversation) -> ProjectConversationCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. Resource identifier of the project creating the conversation.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectConversationCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all conversations in the specified project.
///
/// A builder for the *conversations.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_list("parent")
///              .page_token("duo")
///              .page_size(-93)
///              .filter("aliquyam")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _filter: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationListCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListConversationsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        if let Some(value) = self._filter {
            params.push(("filter", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize", "filter"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/conversations";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The project from which to list all conversation.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectConversationListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectConversationListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectConversationListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// A filter expression that filters conversations listed in the response. In
    /// general, the expression must specify the field name, a comparison operator,
    /// and the value to use for filtering:
    /// <ul>
    ///   <li>The value must be a string, a number, or a boolean.</li>
    ///   <li>The comparison operator must be either `=`,`!=`, `>`, or `<`.</li>
    ///   <li>To filter on multiple expressions, separate the
    ///       expressions with `AND` or `OR` (omitting both implies `AND`).</li>
    ///   <li>For clarity, expressions can be enclosed in parentheses.</li>
    /// </ul>
    /// Only `lifecycle_state` can be filtered on in this way. For example,
    /// the following expression only returns `FINISHED` conversations:
    /// 
    /// `lifecycle_state = "FINISHED"`
    ///
    /// Sets the *filter* query property to the given value.
    pub fn filter(mut self, new_value: &str) -> ProjectConversationListCall<'a, C, A> {
        self._filter = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all phone numbers in the specified project.
///
/// A builder for the *phoneNumbers.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().phone_numbers_list("parent")
///              .show_deleted(true)
///              .page_token("et")
///              .page_size(-48)
///              .doit();
/// # }
/// ```
pub struct ProjectPhoneNumberListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _show_deleted: Option<bool>,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectPhoneNumberListCall<'a, C, A> {}

impl<'a, C, A> ProjectPhoneNumberListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListPhoneNumbersResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.phoneNumbers.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._show_deleted {
            params.push(("showDeleted", value.to_string()));
        }
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "showDeleted", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/phoneNumbers";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The project to list all `PhoneNumber` resources from.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectPhoneNumberListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. Controls whether `PhoneNumber` resources in the
    /// DELETE_REQUESTED
    /// state should be returned. Defaults to false.
    ///
    /// Sets the *show deleted* query property to the given value.
    pub fn show_deleted(mut self, new_value: bool) -> ProjectPhoneNumberListCall<'a, C, A> {
        self._show_deleted = Some(new_value);
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectPhoneNumberListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page.
    /// The default value is 100. The maximum value is 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectPhoneNumberListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectPhoneNumberListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectPhoneNumberListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectPhoneNumberListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all human agent assistants.
///
/// A builder for the *humanAgentAssistants.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().human_agent_assistants_list("parent")
///              .page_token("kasd")
///              .page_size(-87)
///              .doit();
/// # }
/// ```
pub struct ProjectHumanAgentAssistantListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectHumanAgentAssistantListCall<'a, C, A> {}

impl<'a, C, A> ProjectHumanAgentAssistantListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListHumanAgentAssistantsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.humanAgentAssistants.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/humanAgentAssistants";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The project to list all agent assistants from.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectHumanAgentAssistantListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectHumanAgentAssistantListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page.
    /// The default value is 100; the maximum value is 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectHumanAgentAssistantListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectHumanAgentAssistantListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectHumanAgentAssistantListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectHumanAgentAssistantListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all intents in the specified agent.
///
/// A builder for the *agent.intents.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_intents_list("parent")
///              .page_token("Lorem")
///              .page_size(-63)
///              .language_code("invidunt")
///              .intent_view("eirmod")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentIntentListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _language_code: Option<String>,
    _intent_view: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentIntentListCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentIntentListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListIntentsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.intents.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(7 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        if let Some(value) = self._language_code {
            params.push(("languageCode", value.to_string()));
        }
        if let Some(value) = self._intent_view {
            params.push(("intentView", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize", "languageCode", "intentView"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/intents";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The agent to list all intents from.
    /// Format: `projects/<Project ID>/agent`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentIntentListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectAgentIntentListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectAgentIntentListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// Optional. The language to list training phrases, parameters and rich
    /// messages for. If not specified, the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    ///
    /// Sets the *language code* query property to the given value.
    pub fn language_code(mut self, new_value: &str) -> ProjectAgentIntentListCall<'a, C, A> {
        self._language_code = Some(new_value.to_string());
        self
    }
    /// Optional. The resource view to apply to the returned intent.
    ///
    /// Sets the *intent view* query property to the given value.
    pub fn intent_view(mut self, new_value: &str) -> ProjectAgentIntentListCall<'a, C, A> {
        self._intent_view = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentIntentListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentIntentListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentIntentListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Adds a text (chat, for example), or audio (phone recording, for example)
/// message from a participan  into the conversation.
///
/// A builder for the *conversations.participants.analyzeContent* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1AnalyzeContentRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1AnalyzeContentRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().conversations_participants_analyze_content(req, "participant")
///              .doit();
/// # }
/// ```
pub struct ProjectConversationParticipantAnalyzeContentCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1AnalyzeContentRequest,
    _participant: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectConversationParticipantAnalyzeContentCall<'a, C, A> {}

impl<'a, C, A> ProjectConversationParticipantAnalyzeContentCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1AnalyzeContentResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.conversations.participants.analyzeContent",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("participant", self._participant.to_string()));
        for &field in ["alt", "participant"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+participant}:analyzeContent";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+participant}", "participant")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["participant"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1AnalyzeContentRequest) -> ProjectConversationParticipantAnalyzeContentCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the participant this text comes from.
    /// Format: `projects/<Project ID>/conversations/<Conversation
    /// ID>/participants/<Participant ID>`.
    ///
    /// Sets the *participant* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn participant(mut self, new_value: &str) -> ProjectConversationParticipantAnalyzeContentCall<'a, C, A> {
        self._participant = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectConversationParticipantAnalyzeContentCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectConversationParticipantAnalyzeContentCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectConversationParticipantAnalyzeContentCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a session entity type.
/// 
/// If the specified session entity type already exists, overrides the
/// session entity type.
///
/// A builder for the *agent.sessions.entityTypes.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1SessionEntityType;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1SessionEntityType::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_entity_types_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionEntityTypeCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1SessionEntityType,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionEntityTypeCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionEntityTypeCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1SessionEntityType), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.entityTypes.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entityTypes";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1SessionEntityType) -> ProjectAgentSessionEntityTypeCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The session to create a session entity type for.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    /// sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we assume
    /// default '-' user.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentSessionEntityTypeCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionEntityTypeCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionEntityTypeCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionEntityTypeCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns a specific `PhoneNumberOrder`.
///
/// A builder for the *phoneNumberOrders.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().phone_number_orders_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectPhoneNumberOrderGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectPhoneNumberOrderGetCall<'a, C, A> {}

impl<'a, C, A> ProjectPhoneNumberOrderGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1PhoneNumberOrder), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.phoneNumberOrders.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The unique identifier of the order to retrieve.
    /// Format: `projects/<Project ID>/phoneNumberOrders/<Order ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectPhoneNumberOrderGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectPhoneNumberOrderGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectPhoneNumberOrderGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectPhoneNumberOrderGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates multiple new entities in the specified entity type.
/// 
/// Operation <response: google.protobuf.Empty>
///
/// A builder for the *agent.entityTypes.entities.batchCreate* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1BatchCreateEntitiesRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1BatchCreateEntitiesRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_entities_batch_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypeEntityBatchCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1BatchCreateEntitiesRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypeEntityBatchCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypeEntityBatchCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.entities.batchCreate",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entities:batchCreate";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1BatchCreateEntitiesRequest) -> ProjectAgentEntityTypeEntityBatchCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the entity type to create entities in. Format:
    /// `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEntityTypeEntityBatchCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypeEntityBatchCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypeEntityBatchCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypeEntityBatchCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified document.
///
/// A builder for the *agent.knowledgeBases.documents.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_knowledge_bases_documents_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentKnowledgeBaseDocumentGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentKnowledgeBaseDocumentGetCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentKnowledgeBaseDocumentGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Document), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.knowledgeBases.documents.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the document to retrieve.
    /// Format `projects/<Project ID>/knowledgeBases/<Knowledge Base
    /// ID>/documents/<Document ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentKnowledgeBaseDocumentGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentKnowledgeBaseDocumentGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentKnowledgeBaseDocumentGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentKnowledgeBaseDocumentGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes intents in the specified agent.
/// 
/// Operation <response: google.protobuf.Empty>
///
/// A builder for the *agent.intents.batchDelete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1BatchDeleteIntentsRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1BatchDeleteIntentsRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_intents_batch_delete(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentIntentBatchDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1BatchDeleteIntentsRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentIntentBatchDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentIntentBatchDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.intents.batchDelete",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/intents:batchDelete";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1BatchDeleteIntentsRequest) -> ProjectAgentIntentBatchDeleteCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The name of the agent to delete all entities types for. Format:
    /// `projects/<Project ID>/agent`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentIntentBatchDeleteCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentIntentBatchDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentIntentBatchDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentIntentBatchDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Cancels the deletion request for a `PhoneNumber`. This method may only be
/// called on a `PhoneNumber` in the
/// DELETE_REQUESTED state.
///
/// A builder for the *phoneNumbers.undelete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1UndeletePhoneNumberRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1UndeletePhoneNumberRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().phone_numbers_undelete(req, "name")
///              .doit();
/// # }
/// ```
pub struct ProjectPhoneNumberUndeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1UndeletePhoneNumberRequest,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectPhoneNumberUndeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectPhoneNumberUndeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1PhoneNumber), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.phoneNumbers.undelete",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}:undelete";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1UndeletePhoneNumberRequest) -> ProjectPhoneNumberUndeleteCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The unique identifier of the `PhoneNumber` to delete.
    /// Format: `projects/<Project ID>/phoneNumbers/<PhoneNumber ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectPhoneNumberUndeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectPhoneNumberUndeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectPhoneNumberUndeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectPhoneNumberUndeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified document.
///
/// A builder for the *knowledgeBases.documents.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().knowledge_bases_documents_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectKnowledgeBaseDocumentGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectKnowledgeBaseDocumentGetCall<'a, C, A> {}

impl<'a, C, A> ProjectKnowledgeBaseDocumentGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Document), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.knowledgeBases.documents.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the document to retrieve.
    /// Format `projects/<Project ID>/knowledgeBases/<Knowledge Base
    /// ID>/documents/<Document ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectKnowledgeBaseDocumentGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectKnowledgeBaseDocumentGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectKnowledgeBaseDocumentGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectKnowledgeBaseDocumentGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Updates the specified session entity type.
///
/// A builder for the *agent.sessions.entityTypes.patch* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1SessionEntityType;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1SessionEntityType::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_entity_types_patch(req, "name")
///              .update_mask("Lorem")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionEntityTypePatchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1SessionEntityType,
    _name: String,
    _update_mask: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionEntityTypePatchCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionEntityTypePatchCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1SessionEntityType), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.entityTypes.patch",
        //                       http_method: hyper::Method::PATCH });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(5 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        if let Some(value) = self._update_mask {
            params.push(("updateMask", value.to_string()));
        }
        for &field in ["alt", "name", "updateMask"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::PATCH;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1SessionEntityType) -> ProjectAgentSessionEntityTypePatchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The unique identifier of this session entity type. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>`, or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/entityTypes/<Entity Type Display Name>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    /// 
    /// `<Entity Type Display Name>` must be the display name of an existing entity
    /// type in the same agent that will be overridden or supplemented.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentSessionEntityTypePatchCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// Optional. The mask to control which fields get updated.
    ///
    /// Sets the *update mask* query property to the given value.
    pub fn update_mask(mut self, new_value: &str) -> ProjectAgentSessionEntityTypePatchCall<'a, C, A> {
        self._update_mask = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionEntityTypePatchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionEntityTypePatchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionEntityTypePatchCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Uses the specified human agent assistant to come up with suggestions
/// (relevant articles and FAQs) on how to respond to a given conversation.
///
/// A builder for the *humanAgentAssistants.compileSuggestions* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1CompileSuggestionsRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1CompileSuggestionsRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().human_agent_assistants_compile_suggestions(req, "name")
///              .doit();
/// # }
/// ```
pub struct ProjectHumanAgentAssistantCompileSuggestionCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1CompileSuggestionsRequest,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectHumanAgentAssistantCompileSuggestionCall<'a, C, A> {}

impl<'a, C, A> ProjectHumanAgentAssistantCompileSuggestionCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1CompileSuggestionsResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.humanAgentAssistants.compileSuggestions",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}:compileSuggestions";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1CompileSuggestionsRequest) -> ProjectHumanAgentAssistantCompileSuggestionCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The resource name of the agent assistant.
    /// Format: `projects/<Project ID>/humanAgentAssistants/<Human Agent Assistant
    /// ID>`.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectHumanAgentAssistantCompileSuggestionCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectHumanAgentAssistantCompileSuggestionCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectHumanAgentAssistantCompileSuggestionCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectHumanAgentAssistantCompileSuggestionCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Retrieves the specified session entity type.
///
/// A builder for the *agent.sessions.entityTypes.get* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_entity_types_get("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionEntityTypeGetCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionEntityTypeGetCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionEntityTypeGetCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1SessionEntityType), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.entityTypes.get",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the session entity type. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    /// ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    /// Name>`. If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentSessionEntityTypeGetCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionEntityTypeGetCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionEntityTypeGetCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionEntityTypeGetCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Exports the specified agent to a ZIP file.
/// 
/// 
/// Operation <response: ExportAgentResponse,
///            metadata: google.protobuf.Struct>
///
/// A builder for the *agent.export* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1ExportAgentRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1ExportAgentRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_export(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentExportCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1ExportAgentRequest,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentExportCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentExportCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleLongrunningOperation), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.export",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/agent:export";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1ExportAgentRequest) -> ProjectAgentExportCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The project that the agent to export is associated with.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentExportCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentExportCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentExportCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentExportCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Returns the list of all entity types in the specified agent.
///
/// A builder for the *agent.entityTypes.list* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_entity_types_list("parent")
///              .page_token("amet.")
///              .page_size(-100)
///              .language_code("ut")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentEntityTypeListCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _parent: String,
    _page_token: Option<String>,
    _page_size: Option<i32>,
    _language_code: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentEntityTypeListCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentEntityTypeListCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1ListEntityTypesResponse), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.entityTypes.list",
        //                       http_method: hyper::Method::GET });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._page_token {
            params.push(("pageToken", value.to_string()));
        }
        if let Some(value) = self._page_size {
            params.push(("pageSize", value.to_string()));
        }
        if let Some(value) = self._language_code {
            params.push(("languageCode", value.to_string()));
        }
        for &field in ["alt", "parent", "pageToken", "pageSize", "languageCode"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/entityTypes";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::GET;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The agent to list all entity types from.
    /// Format: `projects/<Project ID>/agent`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentEntityTypeListCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The next_page_token value returned from a previous list request.
    ///
    /// Sets the *page token* query property to the given value.
    pub fn page_token(mut self, new_value: &str) -> ProjectAgentEntityTypeListCall<'a, C, A> {
        self._page_token = Some(new_value.to_string());
        self
    }
    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    ///
    /// Sets the *page size* query property to the given value.
    pub fn page_size(mut self, new_value: i32) -> ProjectAgentEntityTypeListCall<'a, C, A> {
        self._page_size = Some(new_value);
        self
    }
    /// Optional. The language to list entity synonyms for. If not specified,
    /// the agent's default language is used.
    /// [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    ///
    /// Sets the *language code* query property to the given value.
    pub fn language_code(mut self, new_value: &str) -> ProjectAgentEntityTypeListCall<'a, C, A> {
        self._language_code = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentEntityTypeListCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentEntityTypeListCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentEntityTypeListCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Deletes the specified session entity type.
///
/// A builder for the *agent.sessions.entityTypes.delete* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_sessions_entity_types_delete("name")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentSessionEntityTypeDeleteCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _name: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentSessionEntityTypeDeleteCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentSessionEntityTypeDeleteCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleProtobufEmpty), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.sessions.entityTypes.delete",
        //                       http_method: hyper::Method::DELETE });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(3 + self._additional_params.len());
        params.push(("name", self._name.to_string()));
        for &field in ["alt", "name"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+name}";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+name}", "name")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["name"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();



        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::DELETE;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    /// Required. The name of the entity type to delete. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    /// ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    /// Name>`. If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// Sets the *name* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn name(mut self, new_value: &str) -> ProjectAgentSessionEntityTypeDeleteCall<'a, C, A> {
        self._name = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentSessionEntityTypeDeleteCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentSessionEntityTypeDeleteCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentSessionEntityTypeDeleteCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates a human agent assistant.
///
/// A builder for the *humanAgentAssistants.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1HumanAgentAssistant;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1HumanAgentAssistant::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().human_agent_assistants_create(req, "parent")
///              .doit();
/// # }
/// ```
pub struct ProjectHumanAgentAssistantCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1HumanAgentAssistant,
    _parent: String,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectHumanAgentAssistantCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectHumanAgentAssistantCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1HumanAgentAssistant), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.humanAgentAssistants.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(4 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        for &field in ["alt", "parent"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/humanAgentAssistants";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1HumanAgentAssistant) -> ProjectHumanAgentAssistantCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The project to create a agent assistant for.
    /// Format: `projects/<Project ID>`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectHumanAgentAssistantCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectHumanAgentAssistantCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectHumanAgentAssistantCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectHumanAgentAssistantCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


/// Creates an intent in the specified agent.
///
/// A builder for the *agent.intents.create* method supported by a *project* resource.
/// It is not used directly, but through a `ProjectMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate hyper_rustls;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_dialogflow2_beta1 as dialogflow2_beta1;
/// use dialogflow2_beta1::GoogleCloudDialogflowV2beta1Intent;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use dialogflow2_beta1::Dialogflow;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = Dialogflow::new(hyper::Client::with_connector(hyper::net::HttpsConnector::new(hyper_rustls::TlsClient::new())), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = GoogleCloudDialogflowV2beta1Intent::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.projects().agent_intents_create(req, "parent")
///              .language_code("eirmod")
///              .intent_view("sanctus")
///              .doit();
/// # }
/// ```
pub struct ProjectAgentIntentCreateCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a Dialogflow<C, A>,
    _request: GoogleCloudDialogflowV2beta1Intent,
    _parent: String,
    _language_code: Option<String>,
    _intent_view: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
    _scopes: BTreeMap<String, ()>
}

impl<'a, C, A> CallBuilder for ProjectAgentIntentCreateCall<'a, C, A> {}

impl<'a, C, A> ProjectAgentIntentCreateCall<'a, C, A> where C: BorrowMut<hyper::Client<hyper_tls::HttpsConnector<hyper::client::HttpConnector>, hyper::Body>>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Box<Future<Item = (hyper::Response<hyper::Body>, GoogleCloudDialogflowV2beta1Intent), Error = cmn::Error> + Send> {
        use url::percent_encoding::{percent_encode, DEFAULT_ENCODE_SET};
        use std::io::{Read, Seek};
        use hyper::header::{HeaderMap, HeaderValue, CONTENT_RANGE, CONTENT_TYPE, CONTENT_LENGTH, USER_AGENT, AUTHORIZATION};
        // let mut dd = DefaultDelegate;
        // let mut dlg: &mut Delegate = match self._delegate {
        //    Some(d) => d,
        //    None => &mut dd
        // };
        //dlg.begin(MethodInfo { id: "dialogflow.projects.agent.intents.create",
        //                       http_method: hyper::Method::POST });
        let mut params: Vec<(&str, String)> = Vec::with_capacity(6 + self._additional_params.len());
        params.push(("parent", self._parent.to_string()));
        if let Some(value) = self._language_code {
            params.push(("languageCode", value.to_string()));
        }
        if let Some(value) = self._intent_view {
            params.push(("intentView", value.to_string()));
        }
        for &field in ["alt", "parent", "languageCode", "intentView"].iter() {
            if self._additional_params.contains_key(field) {
                // dlg.finished(false);
                return Box::new(futures::future::err(Error::FieldClash(field)));

            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = self.hub._base_url.clone() + "v2beta1/{+parent}/intents";
        if self._scopes.len() == 0 {
            self._scopes.insert(Scope::CloudPlatform.as_ref().to_string(), ());
        }

        for &(find_this, param_name) in [("{+parent}", "parent")].iter() {
            let mut replace_with = String::new();
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = value.to_string();
                    break;
                }
            }
            if find_this.as_bytes()[1] == '+' as u8 {
                replace_with = percent_encode(replace_with.as_bytes(), DEFAULT_ENCODE_SET).to_string();
            }
            url = url.replace(find_this, &replace_with);
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["parent"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        use http::Uri;
        let url = url.parse::<Uri>().unwrap();

        let mut json_mime_type = "application/json";
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request).expect("serde to work");
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            let token = match self.hub.auth.borrow_mut().token(self._scopes.keys()) {
                Ok(token) => token,
                Err(_err) => {
                    // match  dlg.token(&*err) {
                    //     Some(token) => token,
                    //    None => {
                    //        dlg.finished(false);
                    //    }
                    //}
                    return Box::new(futures::future::err(Error::MissingToken));

                }
            };
            let auth_header = HeaderValue::from_str(&format!("Authorization: Bearer {}", token.access_token)).unwrap();
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_fut: hyper::client::ResponseFuture = {
                let mut req = hyper::Request::new(hyper::Body::from(""));
                *req.method_mut() = hyper::Method::POST;
                *req.uri_mut() = url.clone();
                {
                    let headers_mut = req.headers_mut();
                    headers_mut.insert(
                        hyper::header::USER_AGENT,
                        http::header::HeaderValue::from_str(
                            &self.hub._user_agent.clone()
                        ).unwrap()
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    // TODO auth_header needs to not have the header name
                    headers_mut.insert(
                        hyper::header::AUTHORIZATION,
                        auth_header
                    );
                }
                {
                    let headers_mut = req.headers_mut();

                    headers_mut.insert(
                        hyper::header::CONTENT_TYPE,
                        HeaderValue::from_str(&json_mime_type.clone()).unwrap()
                    );
                    headers_mut.insert(
                        hyper::header::CONTENT_LENGTH,
                        HeaderValue::from_str(&format!("{}", request_size as u64)).unwrap()
                    );
                }
                let mut buffer = Vec::new();
                request_value_reader.read_to_end(&mut buffer).unwrap();
                {
                    *req.body_mut() = hyper::Body::from(buffer);
                }

                // dlg.pre_request();
                let client = hyper::client::Client::new();
                client.request(req)
            };
            use std::io::Write;
            let final_fut = req_fut.then(|mut result| {
                let res = match result {
                    Ok(r) => r,
                    Err(err) => {
                        return futures::future::err(Error::HttpError(err));
                    }
                };
                if !res.status().is_success() {
                    let json_err = cmn::read_to_string(&res).unwrap();
                    // if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                    //                                    json::from_str(&json_err).ok(),
                    //                                    json::from_str(&json_err).ok()) {
                    //    sleep(d);
                    // }
                    // dlg.finished(false);
                    match json::from_str::<ErrorResponse>(&json_err) {
                        Err(_) => {
                            return futures::future::err(Error::Failure(res));
                        }
                        Ok(serr) => {
                            return futures::future::err(Error::BadRequest(serr));
                        }
                    }
                }
                let result_value = {
                    let json_response = cmn::read_to_string(&res).unwrap();

                    match json::from_str(&json_response) {
                        Ok(decoded) => (res, decoded),
                        Err(err) => {
                            // dlg.response_json_decode_error(&json_response, &err);
                            return futures::future::err(Error::JsonDecodeError(json_response, err));
                        }
                    }
                };

                // dlg.finished(true);
                return futures::future::ok(result_value);
            });
            return Box::new(final_fut);
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: GoogleCloudDialogflowV2beta1Intent) -> ProjectAgentIntentCreateCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// Required. The agent to create a intent for.
    /// Format: `projects/<Project ID>/agent`.
    ///
    /// Sets the *parent* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn parent(mut self, new_value: &str) -> ProjectAgentIntentCreateCall<'a, C, A> {
        self._parent = new_value.to_string();
        self
    }
    /// Optional. The language of training phrases, parameters and rich messages
    /// defined in `intent`. If not specified, the agent's default language is
    /// used. [More than a dozen
    /// languages](https://dialogflow.com/docs/reference/language) are supported.
    /// Note: languages must be enabled in the agent, before they can be used.
    ///
    /// Sets the *language code* query property to the given value.
    pub fn language_code(mut self, new_value: &str) -> ProjectAgentIntentCreateCall<'a, C, A> {
        self._language_code = Some(new_value.to_string());
        self
    }
    /// Optional. The resource view to apply to the returned intent.
    ///
    /// Sets the *intent view* query property to the given value.
    pub fn intent_view(mut self, new_value: &str) -> ProjectAgentIntentCreateCall<'a, C, A> {
        self._intent_view = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ProjectAgentIntentCreateCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known parameters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *upload_protocol* (query-string) - Upload protocol for media (e.g. "raw", "multipart").
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *access_token* (query-string) - OAuth access token.
    /// * *uploadType* (query-string) - Legacy upload protocol for media (e.g. "media", "multipart").
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
    /// * *callback* (query-string) - JSONP
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for response.
    /// * *$.xgafv* (query-string) - V1 error format.
    pub fn param<T>(mut self, name: T, value: T) -> ProjectAgentIntentCreateCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

    /// Identifies the authorization scope for the method you are building.
    ///
    /// Use this method to actively specify which scope should be used, instead the default `Scope` variant
    /// `Scope::CloudPlatform`.
    ///
    /// The `scope` will be added to a set of scopes. This is important as one can maintain access
    /// tokens for more than one scope.
    /// If `None` is specified, then all scopes will be removed and no default scope will be used either.
    /// In that case, you have to specify your API-key using the `key` parameter (see the `param()`
    /// function for details).
    ///
    /// Usually there is more than one suitable scope to authorize an operation, some of which may
    /// encompass more rights than others. For example, for listing resources, a *read-only* scope will be
    /// sufficient, a read-write scope will do as well.
    pub fn add_scope<T, S>(mut self, scope: T) -> ProjectAgentIntentCreateCall<'a, C, A>
                                                        where T: Into<Option<S>>,
                                                              S: AsRef<str> {
        match scope.into() {
          Some(scope) => self._scopes.insert(scope.as_ref().to_string(), ()),
          None => None,
        };
        self
    }
}


